#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_config = require("dotenv/config");
var import_web315 = require("@solana/web3.js");

// src/sdk.ts
var import_web314 = require("@solana/web3.js");
var import_bs58 = __toESM(require("bs58"), 1);

// src/platform/client.ts
var import_web32 = require("@solana/web3.js");

// src/types.ts
var SdkError = class extends Error {
  code;
  details;
  constructor(code, message, details) {
    super(message);
    this.name = "SdkError";
    this.code = code;
    this.details = details;
  }
};
var TransportError = class extends SdkError {
  constructor(message, details) {
    super("TRANSPORT_ERROR", message, details);
    this.name = "TransportError";
  }
};

// src/idl/index.ts
var import_web3 = require("@solana/web3.js");
var import_anchor = require("@coral-xyz/anchor");

// src/idl/pnp_exchange.json
var pnp_exchange_default = {
  address: "6fnYZUSyp3vJxTNnayq5S62d363EFaGARnqYux5bqrxb",
  metadata: {
    name: "pnp_protocol_solana",
    version: "0.1.0",
    spec: "0.1.0",
    description: "Created with Anchor"
  },
  docs: [
    "Main program module for the PnP prediction market protocol"
  ],
  instructions: [
    {
      name: "burn_decision_tokens",
      docs: [
        "Burns decision tokens in exchange for collateral",
        "",
        "# Arguments",
        "* `ctx` - The context containing burning accounts",
        "* `amount` - Amount of decision tokens to burn",
        "* `burn_yes_token` - If true, burn YES tokens; if false, burn NO tokens",
        "",
        "# Returns",
        "* The amount of collateral returned"
      ],
      discriminator: [
        18,
        198,
        214,
        1,
        236,
        94,
        63,
        29
      ],
      accounts: [
        {
          name: "buyer",
          docs: [
            "The buyer's account, must be a signer"
          ],
          writable: true,
          signer: true
        },
        {
          name: "admin",
          docs: [
            "The admin's account, must be a signer"
          ],
          writable: true
        },
        {
          name: "market_creator",
          docs: [
            "The market creator's account"
          ]
        },
        {
          name: "market",
          docs: [
            "The prediction market account"
          ],
          writable: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint account"
          ],
          writable: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_yes_token_account",
          docs: [
            "Buyer's YES token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "buyer_no_token_account",
          docs: [
            "Buyer's NO token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market's collateral token vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_collateral_token_account",
          docs: [
            "Buyer's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "admin_collateral_token_account",
          docs: [
            "Market creator's collateral token account",
            "Admin's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "admin"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_fee_treasury",
          docs: [
            "Creator's fee treasury account"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program interface"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "burn_yes_token",
          type: "bool"
        }
      ],
      returns: "u64"
    },
    {
      name: "buy_v3_tokens",
      docs: [
        "Buy tokens on one side of a V3 market",
        "",
        "# Arguments",
        "* `ctx` - The context containing V3 buy accounts",
        "* `amount` - Amount of collateral to spend",
        "* `side` - Which side to buy (YES or NO)",
        "* `minimum_tokens_out` - Minimum tokens expected (slippage protection)",
        "",
        "# Returns",
        "* The amount of tokens received"
      ],
      discriminator: [
        159,
        2,
        78,
        64,
        237,
        111,
        133,
        248
      ],
      accounts: [
        {
          name: "buyer",
          docs: [
            "Buyer account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "market",
          docs: [
            "P2P Market account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  45,
                  118,
                  51
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "MarketV3"
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint"
          ],
          writable: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint"
          ],
          writable: true
        },
        {
          name: "buyer_yes_token_account",
          docs: [
            "Buyer's YES token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "buyer_no_token_account",
          docs: [
            "Buyer's NO token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market reserve vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint"
          ]
        },
        {
          name: "buyer_collateral_token_account",
          docs: [
            "Buyer's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_program",
          docs: [
            "Token program"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "side",
          type: {
            defined: {
              name: "TokenSide"
            }
          }
        },
        {
          name: "minimum_tokens_out",
          type: "u64"
        }
      ],
      returns: "u64"
    },
    {
      name: "claim_creator_fee",
      docs: [
        "Claims the creator fee from the creator fee treasury",
        "",
        "# Arguments",
        "* `ctx` - The context containing fee claiming accounts",
        "",
        "# Returns",
        "* Result indicating success or error"
      ],
      discriminator: [
        26,
        97,
        138,
        203,
        132,
        171,
        141,
        252
      ],
      accounts: [
        {
          name: "creator",
          writable: true,
          signer: true
        },
        {
          name: "creator_fee_treasury",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  97,
                  116,
                  111,
                  114,
                  95,
                  102,
                  101,
                  101,
                  95,
                  116,
                  114,
                  101,
                  97,
                  115,
                  117,
                  114,
                  121
                ]
              },
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ]
          }
        },
        {
          name: "creator_token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint"
        },
        {
          name: "token_program"
        },
        {
          name: "associated_token_program",
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "claim_creator_fee_legacy",
      docs: [
        "Claims accumulated creator fees from legacy treasury (pre-multi-collateral)",
        "Use this for treasuries created before the multi-collateral update",
        "",
        "# Arguments",
        "* `ctx` - The context containing creator fee claim accounts (legacy PDA)",
        "",
        "# Returns",
        "* Result indicating success or error"
      ],
      discriminator: [
        218,
        83,
        157,
        107,
        200,
        185,
        98,
        202
      ],
      accounts: [
        {
          name: "creator",
          writable: true,
          signer: true
        },
        {
          name: "creator_fee_treasury",
          docs: [
            "Legacy treasury PDA (without collateral mint in seeds)"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  97,
                  116,
                  111,
                  114,
                  95,
                  102,
                  101,
                  101,
                  95,
                  116,
                  114,
                  101,
                  97,
                  115,
                  117,
                  114,
                  121
                ]
              },
              {
                kind: "account",
                path: "creator"
              }
            ]
          }
        },
        {
          name: "creator_token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint"
        },
        {
          name: "token_program"
        },
        {
          name: "associated_token_program",
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "create_market",
      docs: [
        "Creates a new prediction market",
        "",
        "# Arguments",
        "* `ctx` - The context containing market creation accounts",
        "* `question` - The prediction market question/statement",
        "* `initial_liquidity` - Initial liquidity provided to the market",
        "* `end_time` - Unix timestamp when the market ends",
        "",
        "# Returns",
        "* The public key of the newly created market"
      ],
      discriminator: [
        103,
        226,
        97,
        235,
        200,
        188,
        251,
        254
      ],
      accounts: [
        {
          name: "creator",
          writable: true,
          signer: true
        },
        {
          name: "market",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116
                ]
              },
              {
                kind: "account",
                path: "yes_token_mint"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ]
          }
        },
        {
          name: "global_config",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint"
          ],
          writable: true
        },
        {
          name: "creator_collateral_token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "yes_token_mint",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  121,
                  101,
                  115,
                  95,
                  116,
                  111,
                  107,
                  101,
                  110
                ]
              },
              {
                kind: "account",
                path: "global_config.global_id",
                account: "GlobalConfig"
              }
            ]
          }
        },
        {
          name: "no_token_mint",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  110,
                  111,
                  95,
                  116,
                  111,
                  107,
                  101,
                  110
                ]
              },
              {
                kind: "account",
                path: "global_config.global_id",
                account: "GlobalConfig"
              }
            ]
          }
        },
        {
          name: "user_yes_token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "user_no_token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_metadata_program"
        },
        {
          name: "yes_metadata",
          writable: true
        },
        {
          name: "no_metadata",
          writable: true
        },
        {
          name: "creator_fee_treasury",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  97,
                  116,
                  111,
                  114,
                  95,
                  102,
                  101,
                  101,
                  95,
                  116,
                  114,
                  101,
                  97,
                  115,
                  117,
                  114,
                  121
                ]
              },
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ]
          }
        },
        {
          name: "token_program"
        },
        {
          name: "associated_token_program",
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          address: "SysvarRent111111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "question",
          type: "string"
        },
        {
          name: "initial_liquidity",
          type: "u64"
        },
        {
          name: "end_time",
          type: "u64"
        }
      ],
      returns: "pubkey"
    },
    {
      name: "create_market_v2",
      docs: [
        "Creates a new V2 prediction market with deferred token creation",
        "",
        "# Arguments",
        "* `ctx` - The context containing V2 market creation accounts",
        "* `question` - The prediction market question/statement",
        "* `initial_liquidity` - Initial liquidity provided to the market",
        "* `end_time` - Unix timestamp when the market ends",
        "* `creator` - The public key of the market creator",
        "* `yes_odds_bps` - Optional custom odds (100-9900 bps). Default 5000 (50/50)",
        "* `oracle` - Optional custom oracle. Default uses global oracle",
        "",
        "# Returns",
        "* The public key of the newly created market"
      ],
      discriminator: [
        193,
        18,
        155,
        62,
        161,
        124,
        80,
        25
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "Payer who pays for market creation"
          ],
          writable: true,
          signer: true
        },
        {
          name: "creator"
        },
        {
          name: "market",
          docs: [
            "Market account - uses V2 PDA derivation with market ID"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  45,
                  118,
                  50
                ]
              },
              {
                kind: "account",
                path: "global_config.global_id",
                account: "GlobalConfig"
              }
            ]
          }
        },
        {
          name: "market_extension",
          docs: [
            "Optional market extension account for custom odds/oracle",
            "Pass this if you want to set custom odds or oracle"
          ],
          writable: true,
          optional: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint"
          ]
        },
        {
          name: "payer_collateral_token_account",
          docs: [
            "Payer's collateral token account (for initial liquidity transfer)"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "payer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market reserve vault to hold initial liquidity"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_fee_treasury",
          docs: [
            "Creator fee treasury (created if needed)"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  97,
                  116,
                  111,
                  114,
                  95,
                  102,
                  101,
                  101,
                  95,
                  116,
                  114,
                  101,
                  97,
                  115,
                  117,
                  114,
                  121
                ]
              },
              {
                kind: "arg",
                path: "creator"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ]
          }
        },
        {
          name: "token_program",
          docs: [
            "Token program"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "question",
          type: "string"
        },
        {
          name: "initial_liquidity",
          type: "u64"
        },
        {
          name: "end_time",
          type: "u64"
        },
        {
          name: "creator",
          type: "pubkey"
        },
        {
          name: "yes_odds_bps",
          type: {
            option: "u16"
          }
        },
        {
          name: "oracle",
          type: {
            option: "pubkey"
          }
        }
      ],
      returns: "pubkey"
    },
    {
      name: "create_market_v3",
      docs: [
        "Creates a new V3 parimutuel prediction market",
        "",
        "# Arguments",
        "* `ctx` - The context containing V3 market creation accounts",
        "* `question` - The prediction market question/statement",
        "* `initial_amount` - Total initial liquidity to deposit",
        "* `side` - Which side creator is backing (YES or NO)",
        "* `creator_side_cap` - Maximum liquidity allowed on creator's side",
        "* `end_time` - Unix timestamp when the market ends",
        "* `max_pot_ratio` - Maximum pot imbalance ratio",
        "* `creator` - The public key of the market creator",
        "* `odds_bps` - Optional custom odds (100-9900 bps). Default 10000 (all to creator's side)",
        "* `oracle` - Optional custom oracle. Default uses global oracle",
        "",
        "# Returns",
        "* The public key of the newly created V3 market"
      ],
      discriminator: [
        222,
        20,
        31,
        62,
        200,
        59,
        146,
        78
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "creator"
        },
        {
          name: "market",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  45,
                  118,
                  51
                ]
              },
              {
                kind: "account",
                path: "global_config.global_id",
                account: "GlobalConfig"
              }
            ]
          }
        },
        {
          name: "market_extension",
          docs: [
            "Optional market extension for custom odds/oracle"
          ],
          writable: true,
          optional: true
        },
        {
          name: "global_config",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "collateral_token_mint"
        },
        {
          name: "yes_token_mint",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  51,
                  45,
                  121,
                  101,
                  115,
                  45,
                  116,
                  111,
                  107,
                  101,
                  110
                ]
              },
              {
                kind: "account",
                path: "global_config.global_id",
                account: "GlobalConfig"
              }
            ]
          }
        },
        {
          name: "no_token_mint",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  51,
                  45,
                  110,
                  111,
                  45,
                  116,
                  111,
                  107,
                  101,
                  110
                ]
              },
              {
                kind: "account",
                path: "global_config.global_id",
                account: "GlobalConfig"
              }
            ]
          }
        },
        {
          name: "payer_collateral_token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "payer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_yes_token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "arg",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_no_token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "arg",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_fee_treasury",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  97,
                  116,
                  111,
                  114,
                  95,
                  102,
                  101,
                  101,
                  95,
                  116,
                  114,
                  101,
                  97,
                  115,
                  117,
                  114,
                  121
                ]
              },
              {
                kind: "arg",
                path: "creator"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ]
          }
        },
        {
          name: "token_program"
        },
        {
          name: "associated_token_program",
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "question",
          type: "string"
        },
        {
          name: "initial_amount",
          type: "u64"
        },
        {
          name: "side",
          type: {
            defined: {
              name: "TokenSide"
            }
          }
        },
        {
          name: "creator_side_cap",
          type: "u64"
        },
        {
          name: "end_time",
          type: "u64"
        },
        {
          name: "max_pot_ratio",
          type: "u32"
        },
        {
          name: "creator",
          type: "pubkey"
        },
        {
          name: "odds_bps",
          type: {
            option: "u16"
          }
        },
        {
          name: "oracle",
          type: {
            option: "pubkey"
          }
        }
      ],
      returns: "pubkey"
    },
    {
      name: "creator_refund",
      docs: [
        "Allows creator to claim refund if market is expired and not resolvable",
        "",
        "# Arguments",
        "* `ctx` - The context containing creator refund accounts"
      ],
      discriminator: [
        131,
        96,
        75,
        61,
        131,
        158,
        144,
        19
      ],
      accounts: [
        {
          name: "creator",
          docs: [
            "Market creator account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "market",
          docs: [
            "Market account"
          ],
          writable: true
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint account"
          ],
          optional: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint account"
          ],
          optional: true
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market's collateral token vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint account"
          ]
        },
        {
          name: "creator_collateral_token_account",
          docs: [
            "Creator's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_program",
          docs: [
            "Token program interface"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "creator_refund_v2",
      docs: [
        "V2 version: Allows creator to claim refund for V2 markets using market-id based seeds",
        "",
        "# Arguments",
        "* `ctx` - The context containing creator refund accounts"
      ],
      discriminator: [
        93,
        161,
        160,
        92,
        75,
        205,
        235,
        184
      ],
      accounts: [
        {
          name: "creator",
          docs: [
            "Market creator account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "market",
          docs: [
            "Market account"
          ],
          writable: true
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint account"
          ],
          optional: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint account"
          ],
          optional: true
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market's collateral token vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint account"
          ]
        },
        {
          name: "creator_collateral_token_account",
          docs: [
            "Creator's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_program",
          docs: [
            "Token program interface"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "creator_refund_v3",
      docs: [
        "Creator can claim refund if no one bet against them (V3)",
        "",
        "# Arguments",
        "* `ctx` - The context containing V3 creator refund accounts",
        "",
        "# Returns",
        "* The amount refunded to creator"
      ],
      discriminator: [
        30,
        48,
        48,
        62,
        129,
        212,
        67,
        70
      ],
      accounts: [
        {
          name: "creator",
          docs: [
            "Creator account (must be market creator)"
          ],
          writable: true,
          signer: true
        },
        {
          name: "market",
          docs: [
            "P2P Market account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  45,
                  118,
                  51
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "MarketV3"
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market reserve vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint"
          ]
        },
        {
          name: "creator_collateral_token_account",
          docs: [
            "Creator's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_program",
          docs: [
            "Token program"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [],
      returns: "u64"
    },
    {
      name: "get_no_price",
      discriminator: [
        21,
        75,
        13,
        51,
        64,
        19,
        143,
        223
      ],
      accounts: [
        {
          name: "market"
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint"
          ]
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint"
          ]
        }
      ],
      args: [],
      returns: "u64"
    },
    {
      name: "get_price_for_market",
      docs: [
        "Gets the price of YES and NO tokens for a given market",
        "",
        "# Arguments",
        "* `ctx` - The context containing the market and mint accounts",
        "",
        "# Returns",
        "* (YES price, NO price)"
      ],
      discriminator: [
        74,
        121,
        126,
        27,
        228,
        50,
        232,
        98
      ],
      accounts: [
        {
          name: "market"
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint"
          ]
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint"
          ]
        }
      ],
      args: []
    },
    {
      name: "get_yes_price",
      discriminator: [
        55,
        53,
        8,
        152,
        205,
        158,
        118,
        52
      ],
      accounts: [
        {
          name: "market"
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint"
          ]
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint"
          ]
        }
      ],
      args: [],
      returns: "u64"
    },
    {
      name: "init_protocol",
      docs: [
        "Initializes the protocol with global configuration settings",
        "",
        "# Arguments",
        "* `ctx` - The context containing protocol initialization accounts",
        "* `yes_global_metadata` - Metadata template for YES tokens",
        "* `no_global_metadata` - Metadata template for NO tokens"
      ],
      discriminator: [
        3,
        188,
        141,
        237,
        225,
        226,
        232,
        210
      ],
      accounts: [
        {
          name: "payer",
          docs: [
            "Payer account that will pay for account creation"
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account that stores protocol settings"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Mint account for the token used as collateral"
          ]
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "yes_global_metadata",
          type: "string"
        },
        {
          name: "no_global_metadata",
          type: "string"
        },
        {
          name: "initial_fee",
          type: "u64"
        },
        {
          name: "creator_fee",
          type: "u64"
        },
        {
          name: "oracle_program",
          type: "pubkey"
        },
        {
          name: "min_liquidity",
          type: "u64"
        },
        {
          name: "buffer_period",
          type: "u64"
        },
        {
          name: "burn_fee",
          type: "u64"
        }
      ]
    },
    {
      name: "mint_decision_tokens",
      docs: [
        "Mints new decision tokens (YES or NO) in exchange for collateral",
        "",
        "# Arguments",
        "* `ctx` - The context containing minting accounts",
        "* `amount` - Amount of collateral to exchange for decision tokens",
        "* `buy_yes_token` - If true, mint YES tokens; if false, mint NO tokens",
        "",
        "# Returns",
        "* The amount of decision tokens minted"
      ],
      discriminator: [
        226,
        180,
        53,
        125,
        168,
        69,
        114,
        25
      ],
      accounts: [
        {
          name: "buyer",
          docs: [
            "The buyer's account, must be a signer"
          ],
          writable: true,
          signer: true
        },
        {
          name: "admin",
          docs: [
            "The admin's account, must be a signer"
          ],
          writable: true
        },
        {
          name: "market_creator",
          docs: [
            "The market creator's account"
          ]
        },
        {
          name: "market",
          docs: [
            "The prediction market account"
          ],
          writable: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint account"
          ],
          writable: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_yes_token_account",
          docs: [
            "Buyer's YES token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "buyer_no_token_account",
          docs: [
            "Buyer's NO token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market's collateral token vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_collateral_token_account",
          docs: [
            "Buyer's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "admin_collateral_token_account",
          docs: [
            "Market creator's collateral token account",
            "Admin's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "admin"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_fee_treasury",
          docs: [
            "Creator's fee treasury account"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program interface"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "buy_yes_token",
          type: "bool"
        },
        {
          name: "minimum_out",
          type: "u64"
        }
      ],
      returns: "u64"
    },
    {
      name: "redeem_position",
      docs: [
        "Redeems winning tokens for collateral after market settlement",
        "",
        "# Arguments",
        "* `ctx` - The context containing redemption accounts",
        "",
        "# Returns",
        "* The amount of collateral redeemed"
      ],
      discriminator: [
        51,
        138,
        49,
        229,
        33,
        216,
        19,
        97
      ],
      accounts: [
        {
          name: "buyer",
          docs: [
            "The buyer's account, must be a signer"
          ],
          writable: true,
          signer: true
        },
        {
          name: "admin",
          docs: [
            "The admin's account, must be a signer"
          ],
          writable: true
        },
        {
          name: "market_creator",
          docs: [
            "The market creator's account"
          ]
        },
        {
          name: "market",
          docs: [
            "The prediction market account"
          ],
          writable: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint account"
          ],
          writable: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_yes_token_account",
          docs: [
            "Buyer's YES token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "buyer_no_token_account",
          docs: [
            "Buyer's NO token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market's collateral token vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_collateral_token_account",
          docs: [
            "Buyer's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "admin_collateral_token_account",
          docs: [
            "Market creator's collateral token account",
            "Admin's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "admin"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_fee_treasury",
          docs: [
            "Creator's fee treasury account"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program interface"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [],
      returns: "u64"
    },
    {
      name: "redeem_position_v2",
      discriminator: [
        21,
        131,
        209,
        12,
        53,
        125,
        168,
        130
      ],
      accounts: [
        {
          name: "buyer",
          docs: [
            "The buyer's account, must be a signer"
          ],
          writable: true,
          signer: true
        },
        {
          name: "admin",
          docs: [
            "The admin's account, must be a signer"
          ],
          writable: true
        },
        {
          name: "market_creator",
          docs: [
            "The market creator's account"
          ]
        },
        {
          name: "market",
          docs: [
            "The prediction market account"
          ],
          writable: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint account"
          ],
          writable: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_yes_token_account",
          docs: [
            "Buyer's YES token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "buyer_no_token_account",
          docs: [
            "Buyer's NO token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market's collateral token vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_collateral_token_account",
          docs: [
            "Buyer's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "admin_collateral_token_account",
          docs: [
            "Market creator's collateral token account",
            "Admin's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "admin"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_fee_treasury",
          docs: [
            "Creator's fee treasury account"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program interface"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [],
      returns: "u64"
    },
    {
      name: "redeem_v3_position",
      docs: [
        "Redeem winning position from a settled V3 market",
        "",
        "# Arguments",
        "* `ctx` - The context containing V3 redemption accounts",
        "",
        "# Returns",
        "* The amount of collateral redeemed"
      ],
      discriminator: [
        35,
        233,
        101,
        97,
        195,
        80,
        220,
        57
      ],
      accounts: [
        {
          name: "redeemer",
          docs: [
            "Redeemer account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "market",
          docs: [
            "P2P Market account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  45,
                  118,
                  51
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "MarketV3"
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint"
          ],
          writable: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint"
          ],
          writable: true
        },
        {
          name: "redeemer_yes_token_account",
          docs: [
            "Redeemer's YES token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "redeemer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "redeemer_no_token_account",
          docs: [
            "Redeemer's NO token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "redeemer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market reserve vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint"
          ]
        },
        {
          name: "redeemer_collateral_token_account",
          docs: [
            "Redeemer's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "redeemer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "admin",
          docs: [
            "Admin account"
          ],
          writable: true
        },
        {
          name: "admin_collateral_token_account",
          docs: [
            "Admin's collateral token account (for platform fee)"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "admin"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_fee_treasury",
          docs: [
            "Creator's fee treasury (for creator fee)"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [],
      returns: "u64"
    },
    {
      name: "set_buffer_period",
      docs: [
        "Sets the buffer period for market resolution",
        "",
        "# Arguments",
        "* `ctx` - The context containing buffer period setting accounts",
        "* `buffer_period` - The new buffer period in seconds"
      ],
      discriminator: [
        214,
        74,
        140,
        200,
        87,
        28,
        33,
        245
      ],
      accounts: [
        {
          name: "admin",
          docs: [
            "Admin account (must be the current admin)"
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "buffer_period",
          type: "u64"
        }
      ]
    },
    {
      name: "set_burn_fee",
      docs: [
        "Sets the burn fee for the protocol",
        "",
        "# Arguments",
        "* `ctx` - The context containing fee setting accounts",
        "* `new_fee` - The new burn fee value",
        "",
        "# Returns",
        "* Result indicating success or error"
      ],
      discriminator: [
        42,
        181,
        26,
        185,
        180,
        168,
        128,
        181
      ],
      accounts: [
        {
          name: "authority",
          docs: [
            "The authority attempting to set the fee. Must be the admin."
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "The global configuration account storing protocol settings"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "new_fee",
          type: "u64"
        }
      ]
    },
    {
      name: "set_creator_fee",
      docs: [
        "Sets the creator fee percentage that creators receive from trading fees",
        "",
        "# Arguments",
        "* `ctx` - The context containing fee setting accounts",
        "* `new_fee` - The new creator fee value (must be <= 20% of protocol fee)",
        "",
        "# Returns",
        "* Result indicating success or error"
      ],
      discriminator: [
        188,
        13,
        191,
        116,
        68,
        13,
        254,
        218
      ],
      accounts: [
        {
          name: "authority",
          docs: [
            "The authority attempting to set the fee. Must be the admin."
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "The global configuration account storing protocol settings"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "new_fee",
          type: "u64"
        }
      ]
    },
    {
      name: "set_market_resolvable",
      docs: [
        "Sets the resolvable status for a market",
        "",
        "# Arguments",
        "* `ctx` - The context containing market resolvable setting accounts",
        "* `resolvable` - The new resolvable status",
        "* `force_resolve` - Whether to force resolve (allow immediate refunds)"
      ],
      discriminator: [
        248,
        31,
        54,
        169,
        19,
        42,
        126,
        93
      ],
      accounts: [
        {
          name: "authority",
          docs: [
            "Admin or oracle account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "market",
          docs: [
            "Market account to update"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116
                ]
              },
              {
                kind: "account",
                path: "market.yes_token_mint",
                account: "Market"
              },
              {
                kind: "account",
                path: "market.no_token_mint",
                account: "Market"
              }
            ]
          }
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint account"
          ]
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint account"
          ]
        }
      ],
      args: [
        {
          name: "resolvable",
          type: "bool"
        },
        {
          name: "force_resolve",
          type: {
            option: "bool"
          }
        }
      ]
    },
    {
      name: "set_market_resolvable_v2",
      docs: [
        "Sets the resolvable status for a V2 market and creates tokens if needed",
        "",
        "# Arguments",
        "* `ctx` - The context containing V2 market resolvable setting accounts",
        "* `market_id` - The market ID",
        "* `resolvable` - The new resolvable status",
        "* `force_resolve` - Whether to force resolve (allow immediate refunds)"
      ],
      discriminator: [
        74,
        223,
        187,
        6,
        245,
        19,
        220,
        253
      ],
      accounts: [
        {
          name: "authority",
          docs: [
            "Admin or oracle account (pays for token creation)"
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "market",
          docs: [
            "V2 Market account to update"
          ],
          writable: true
        },
        {
          name: "market_extension",
          docs: [
            "Optional market extension - pass if market has custom oracle/odds"
          ],
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  95,
                  101,
                  120,
                  116
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "Market"
              }
            ]
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint"
          ]
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint (created by admin)"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  121,
                  101,
                  115,
                  95,
                  116,
                  111,
                  107,
                  101,
                  110
                ]
              },
              {
                kind: "arg",
                path: "market_id"
              }
            ]
          }
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint (created by admin)"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  110,
                  111,
                  95,
                  116,
                  111,
                  107,
                  101,
                  110
                ]
              },
              {
                kind: "arg",
                path: "market_id"
              }
            ]
          }
        },
        {
          name: "creator",
          docs: [
            "Original market creator (for receiving initial tokens)"
          ]
        },
        {
          name: "creator_yes_token_account",
          docs: [
            "Creator's YES token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_no_token_account",
          docs: [
            "Creator's NO token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "creator"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_metadata_program",
          docs: [
            "Token metadata program"
          ]
        },
        {
          name: "yes_metadata",
          docs: [
            "YES token metadata account"
          ],
          writable: true
        },
        {
          name: "no_metadata",
          docs: [
            "NO token metadata account"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          docs: [
            "Rent sysvar"
          ],
          address: "SysvarRent111111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "market_id",
          type: "u64"
        },
        {
          name: "resolvable",
          type: "bool"
        },
        {
          name: "force_resolve",
          type: {
            option: "bool"
          }
        }
      ]
    },
    {
      name: "set_market_resolvable_v3",
      docs: [
        "Set market resolvable status for V3 market",
        "",
        "# Arguments",
        "* `ctx` - The context containing V3 market and global config",
        "* `resolvable` - Whether the market should be resolvable",
        "",
        "# Returns",
        "* Result indicating success or error"
      ],
      discriminator: [
        99,
        37,
        90,
        125,
        115,
        239,
        60,
        162
      ],
      accounts: [
        {
          name: "authority",
          docs: [
            "Authority (admin or oracle)"
          ],
          writable: true,
          signer: true
        },
        {
          name: "market",
          docs: [
            "V3 Market account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  45,
                  118,
                  51
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "MarketV3"
              }
            ]
          }
        },
        {
          name: "market_extension",
          docs: [
            "Optional market extension - pass if market has custom oracle"
          ],
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  95,
                  118,
                  51,
                  95,
                  101,
                  120,
                  116
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "MarketV3"
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "resolvable",
          type: "bool"
        }
      ]
    },
    {
      name: "set_min_liquidity",
      docs: [
        "Sets the minimum liquidity required for a market",
        "",
        "# Arguments",
        "* `ctx` - The context containing fee setting accounts",
        "* `new_min_liquidity` - The new minimum liquidity value",
        "",
        "# Returns",
        "* Result indicating success or error"
      ],
      discriminator: [
        162,
        147,
        87,
        130,
        193,
        136,
        3,
        58
      ],
      accounts: [
        {
          name: "authority",
          docs: [
            "The authority attempting to set the fee. Must be the admin."
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "The global configuration account storing protocol settings"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "new_min_liquidity",
          type: "u64"
        }
      ]
    },
    {
      name: "set_taker_fee",
      docs: [
        "Sets the protocol's taker fee percentage",
        "",
        "# Arguments",
        "* `ctx` - The context containing fee setting accounts",
        "* `new_fee` - The new fee value (between 0-10000, representing 0-100%)"
      ],
      discriminator: [
        182,
        139,
        233,
        12,
        57,
        127,
        45,
        244
      ],
      accounts: [
        {
          name: "authority",
          docs: [
            "The authority attempting to set the fee. Must be the admin."
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "The global configuration account storing protocol settings"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "new_fee",
          type: "u64"
        }
      ]
    },
    {
      name: "set_trading_paused",
      docs: [
        "Sets the trading pause status for the protocol",
        "",
        "# Arguments",
        "* `ctx` - The context containing trading pause setting accounts",
        "* `trading_paused` - Whether trading should be paused (true) or enabled (false)"
      ],
      discriminator: [
        184,
        179,
        206,
        146,
        99,
        185,
        77,
        231
      ],
      accounts: [
        {
          name: "authority",
          docs: [
            "The authority attempting to set the fee. Must be the admin."
          ],
          writable: true,
          signer: true
        },
        {
          name: "global_config",
          docs: [
            "The global configuration account storing protocol settings"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "trading_paused",
          type: "bool"
        }
      ]
    },
    {
      name: "settle_market",
      docs: [
        "Settles a market by determining the winning outcome",
        "",
        "# Arguments",
        "* `ctx` - The context containing settlement accounts",
        "* `yes_winner` - If true, YES tokens win; if false, NO tokens win",
        "",
        "# Returns",
        "* The winning token type"
      ],
      discriminator: [
        193,
        153,
        95,
        216,
        166,
        6,
        144,
        217
      ],
      accounts: [
        {
          name: "buyer",
          docs: [
            "The buyer's account, must be a signer"
          ],
          writable: true,
          signer: true
        },
        {
          name: "admin",
          docs: [
            "The admin's account, must be a signer"
          ],
          writable: true
        },
        {
          name: "market_creator",
          docs: [
            "The market creator's account"
          ]
        },
        {
          name: "market",
          docs: [
            "The prediction market account"
          ],
          writable: true
        },
        {
          name: "global_config",
          docs: [
            "Global configuration account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "yes_token_mint",
          docs: [
            "YES token mint account"
          ],
          writable: true
        },
        {
          name: "no_token_mint",
          docs: [
            "NO token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_yes_token_account",
          docs: [
            "Buyer's YES token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "yes_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "buyer_no_token_account",
          docs: [
            "Buyer's NO token account"
          ],
          writable: true,
          optional: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "no_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "market_reserve_vault",
          docs: [
            "Market's collateral token vault"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "market"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "collateral_token_mint",
          docs: [
            "Collateral token mint account"
          ],
          writable: true
        },
        {
          name: "buyer_collateral_token_account",
          docs: [
            "Buyer's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "buyer"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "admin_collateral_token_account",
          docs: [
            "Market creator's collateral token account",
            "Admin's collateral token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "admin"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "collateral_token_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "creator_fee_treasury",
          docs: [
            "Creator's fee treasury account"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program interface"
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program"
          ],
          address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
        },
        {
          name: "system_program",
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "yes_winner",
          type: "bool"
        }
      ],
      returns: {
        defined: {
          name: "WinningToken"
        }
      }
    },
    {
      name: "settle_market_v3",
      docs: [
        "Settle a V3 market by determining winning side",
        "",
        "# Arguments",
        "* `ctx` - The context containing V3 settlement accounts",
        "* `yes_winner` - If true, YES side wins; if false, NO side wins",
        "",
        "# Returns",
        "* The winning token type"
      ],
      discriminator: [
        137,
        43,
        217,
        201,
        230,
        152,
        227,
        248
      ],
      accounts: [
        {
          name: "settler",
          docs: [
            "Settler account (must be admin, global oracle, or custom oracle)"
          ],
          writable: true,
          signer: true
        },
        {
          name: "market",
          docs: [
            "P2P Market account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  45,
                  118,
                  51
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "MarketV3"
              }
            ]
          }
        },
        {
          name: "market_extension",
          docs: [
            "Optional market extension - pass if market has custom oracle"
          ],
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  95,
                  118,
                  51,
                  95,
                  101,
                  120,
                  116
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "MarketV3"
              }
            ]
          }
        },
        {
          name: "global_config",
          docs: [
            "Global configuration"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "yes_winner",
          type: "bool"
        }
      ],
      returns: {
        defined: {
          name: "WinningToken"
        }
      }
    },
    {
      name: "update_creator_v3",
      docs: [
        "Updates the creator of a V3 market",
        "",
        "# Arguments",
        "* `ctx` - The context containing update accounts",
        "* `new_creator` - The new creator's public key",
        "",
        "# Returns",
        "* Result indicating success or failure"
      ],
      discriminator: [
        192,
        95,
        207,
        42,
        161,
        180,
        33,
        62
      ],
      accounts: [
        {
          name: "current_creator",
          docs: [
            "Current creator (must sign)"
          ],
          writable: true,
          signer: true
        },
        {
          name: "new_creator"
        },
        {
          name: "market",
          docs: [
            "Market account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  97,
                  114,
                  107,
                  101,
                  116,
                  45,
                  118,
                  51
                ]
              },
              {
                kind: "account",
                path: "market.id",
                account: "MarketV3"
              }
            ]
          }
        }
      ],
      args: [
        {
          name: "new_creator",
          type: "pubkey"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "GlobalConfig",
      discriminator: [
        149,
        8,
        156,
        202,
        160,
        252,
        176,
        217
      ]
    },
    {
      name: "Market",
      discriminator: [
        219,
        190,
        213,
        55,
        0,
        227,
        198,
        154
      ]
    },
    {
      name: "MarketExtension",
      discriminator: [
        37,
        143,
        0,
        22,
        58,
        40,
        52,
        44
      ]
    },
    {
      name: "MarketV3",
      discriminator: [
        247,
        134,
        112,
        200,
        45,
        95,
        27,
        136
      ]
    },
    {
      name: "MarketV3Extension",
      discriminator: [
        66,
        142,
        160,
        171,
        84,
        68,
        153,
        246
      ]
    }
  ],
  events: [
    {
      name: "BufferPeriodUpdated",
      discriminator: [
        50,
        193,
        188,
        146,
        213,
        236,
        63,
        224
      ]
    },
    {
      name: "BurnDecisionTokensEvent",
      discriminator: [
        194,
        248,
        24,
        110,
        133,
        210,
        96,
        232
      ]
    },
    {
      name: "BuyV3TokensEvent",
      discriminator: [
        137,
        174,
        78,
        218,
        200,
        120,
        38,
        7
      ]
    },
    {
      name: "CreatorRefundEvent",
      discriminator: [
        230,
        23,
        204,
        95,
        135,
        31,
        5,
        25
      ]
    },
    {
      name: "CreatorRefundV3Event",
      discriminator: [
        164,
        41,
        21,
        115,
        249,
        137,
        17,
        136
      ]
    },
    {
      name: "CreatorUpdatedV3Event",
      discriminator: [
        255,
        181,
        17,
        184,
        199,
        123,
        162,
        190
      ]
    },
    {
      name: "FeeEvent",
      discriminator: [
        73,
        79,
        78,
        127,
        184,
        213,
        13,
        220
      ]
    },
    {
      name: "MarketCreatedEvent",
      discriminator: [
        130,
        142,
        5,
        16,
        107,
        160,
        73,
        124
      ]
    },
    {
      name: "MarketResolvableUpdated",
      discriminator: [
        101,
        255,
        127,
        205,
        46,
        146,
        153,
        157
      ]
    },
    {
      name: "MarketResolvableV3Event",
      discriminator: [
        8,
        161,
        76,
        225,
        143,
        213,
        139,
        158
      ]
    },
    {
      name: "MarketV2CreatedEvent",
      discriminator: [
        39,
        108,
        151,
        231,
        171,
        113,
        198,
        175
      ]
    },
    {
      name: "MarketV2ResolvableUpdated",
      discriminator: [
        250,
        22,
        126,
        96,
        59,
        231,
        75,
        200
      ]
    },
    {
      name: "MarketV3CreatedEvent",
      discriminator: [
        72,
        134,
        87,
        64,
        79,
        167,
        9,
        189
      ]
    },
    {
      name: "MintDecisionTokensEvent",
      discriminator: [
        244,
        132,
        127,
        247,
        11,
        218,
        227,
        77
      ]
    },
    {
      name: "PriceGetterEvent",
      discriminator: [
        154,
        255,
        209,
        101,
        176,
        232,
        166,
        73
      ]
    },
    {
      name: "RedeemPositionEvent",
      discriminator: [
        229,
        215,
        73,
        152,
        17,
        193,
        28,
        179
      ]
    },
    {
      name: "RedeemV3PositionEvent",
      discriminator: [
        246,
        195,
        218,
        185,
        221,
        119,
        7,
        51
      ]
    },
    {
      name: "SetFeeEvent",
      discriminator: [
        169,
        3,
        1,
        148,
        197,
        127,
        147,
        69
      ]
    },
    {
      name: "SettleMarketEvent",
      discriminator: [
        220,
        116,
        83,
        65,
        32,
        237,
        196,
        165
      ]
    },
    {
      name: "SettleMarketV3Event",
      discriminator: [
        156,
        110,
        168,
        141,
        88,
        142,
        44,
        100
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "NotCreator",
      msg: "Only the current creator can update the creator"
    },
    {
      code: 6001,
      name: "MarketResolved",
      msg: "Market is already resolved"
    },
    {
      code: 6002,
      name: "SameCreator",
      msg: "Cannot set creator to the same address"
    }
  ],
  types: [
    {
      name: "BufferPeriodUpdated",
      docs: [
        "Event emitted when buffer period is updated"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "buffer_period",
            docs: [
              "New buffer period in seconds"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BurnDecisionTokensEvent",
      docs: [
        "Event emitted when decision tokens are burned"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "buyer",
            docs: [
              "Public key of the token burner"
            ],
            type: "pubkey"
          },
          {
            name: "market",
            docs: [
              "Public key of the prediction market"
            ],
            type: "pubkey"
          },
          {
            name: "amount",
            docs: [
              "Amount of decision tokens burned"
            ],
            type: "u64"
          },
          {
            name: "collateral_token_amount",
            docs: [
              "Amount of collateral tokens returned to user (after burn fee)"
            ],
            type: "u64"
          },
          {
            name: "burn_fee_amount",
            docs: [
              "Amount of burn fee sent to admin"
            ],
            type: "u64"
          },
          {
            name: "is_yes",
            type: "bool"
          }
        ]
      }
    },
    {
      name: "BuyV3TokensEvent",
      type: {
        kind: "struct",
        fields: [
          {
            name: "buyer",
            type: "pubkey"
          },
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "side",
            type: {
              defined: {
                name: "TokenSide"
              }
            }
          },
          {
            name: "collateral_spent",
            type: "u64"
          },
          {
            name: "tokens_received",
            type: "u64"
          },
          {
            name: "yes_pot_reserve",
            type: "u64"
          },
          {
            name: "no_pot_reserve",
            type: "u64"
          },
          {
            name: "creator_fee",
            type: "u64"
          },
          {
            name: "admin_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "CreatorRefundEvent",
      docs: [
        "Event emitted when creator claims refund"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "market_id",
            docs: [
              "Market ID"
            ],
            type: "u64"
          },
          {
            name: "market_address",
            docs: [
              "Market address (PDA)"
            ],
            type: "pubkey"
          },
          {
            name: "creator",
            docs: [
              "Creator public key"
            ],
            type: "pubkey"
          },
          {
            name: "refund_amount",
            docs: [
              "Amount refunded"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "CreatorRefundV3Event",
      type: {
        kind: "struct",
        fields: [
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "refund_amount",
            type: "u64"
          },
          {
            name: "creator_side",
            type: {
              defined: {
                name: "TokenSide"
              }
            }
          }
        ]
      }
    },
    {
      name: "CreatorUpdatedV3Event",
      type: {
        kind: "struct",
        fields: [
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "market_id",
            type: "u64"
          },
          {
            name: "old_creator",
            type: "pubkey"
          },
          {
            name: "new_creator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "FeeEvent",
      docs: [
        "Event emitted when protocol fee is set or updated"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "fee",
            docs: [
              "Protocol fee in basis points (10000 = 100%)"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "GlobalConfig",
      docs: [
        "Global configuration account that stores protocol-wide settings and parameters"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "admin",
            docs: [
              "The admin pubkey that has authority to modify protocol settings"
            ],
            type: "pubkey"
          },
          {
            name: "oracle_program",
            docs: [
              "The oracle program ID used for resolving prediction markets",
              "not used right now."
            ],
            type: "pubkey"
          },
          {
            name: "fee",
            docs: [
              "Protocol fee taken from trades (between 0-10000, representing 0-100%)",
              "all the fee goes to the admin, admin can than distribute it to token holders and lp's (via the lp pool program that will be developed later)"
            ],
            type: "u64"
          },
          {
            name: "creator_fee",
            type: "u64"
          },
          {
            name: "bump",
            docs: [
              "PDA bump seed"
            ],
            type: "u8"
          },
          {
            name: "yes_global_metadata",
            docs: [
              "Metadata template for YES tokens"
            ],
            type: "string"
          },
          {
            name: "no_global_metadata",
            docs: [
              "Metadata template for NO tokens"
            ],
            type: "string"
          },
          {
            name: "collateral_token_mint",
            docs: [
              "Mint address of the token used as collateral"
            ],
            type: "pubkey"
          },
          {
            name: "global_id",
            docs: [
              "Incrementing ID used to generate unique market identifiers"
            ],
            type: "u64"
          },
          {
            name: "min_liquidity",
            docs: [
              "Minimum liquidity in whole tokens (scaled by collateral decimals at validation)",
              "e.g., min_liquidity=10 means 10 tokens regardless of decimal places"
            ],
            type: "u64"
          },
          {
            name: "buffer_period",
            docs: [
              "Buffer period in seconds before market can be resolved"
            ],
            type: "u64"
          },
          {
            name: "burn_fee",
            type: "u64"
          },
          {
            name: "trading_paused",
            docs: [
              "Trading pause flag - when true, all trading operations are disabled"
            ],
            type: "bool"
          }
        ]
      }
    },
    {
      name: "Market",
      docs: [
        "Represents a prediction market where users can trade YES/NO tokens based on an outcome"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "id",
            docs: [
              "Unique identifier for this market"
            ],
            type: "u64"
          },
          {
            name: "resolved",
            docs: [
              "Whether the market has been resolved with a winning outcome"
            ],
            type: "bool"
          },
          {
            name: "market_reserves",
            docs: [
              "Total amount of collateral tokens held in reserve"
            ],
            type: "u64"
          },
          {
            name: "collateral_token",
            docs: [
              "Mint address of the token used as collateral"
            ],
            type: "pubkey"
          },
          {
            name: "winning_token_id",
            docs: [
              "The winning token type after market resolution (None, Yes, or No)"
            ],
            type: {
              defined: {
                name: "WinningToken"
              }
            }
          },
          {
            name: "yes_token_mint",
            docs: [
              "Mint address for YES outcome tokens"
            ],
            type: "pubkey"
          },
          {
            name: "no_token_mint",
            docs: [
              "Mint address for NO outcome tokens"
            ],
            type: "pubkey"
          },
          {
            name: "yes_token_supply_minted",
            docs: [
              "Total supply of YES tokens that have been minted"
            ],
            type: "u64"
          },
          {
            name: "no_token_supply_minted",
            docs: [
              "Total supply of NO tokens that have been minted"
            ],
            type: "u64"
          },
          {
            name: "creator",
            docs: [
              "Public key of the market creator"
            ],
            type: "pubkey"
          },
          {
            name: "creator_fee_treasury",
            docs: [
              "Public key of the creator's fee treasury"
            ],
            type: "pubkey"
          },
          {
            name: "question",
            docs: [
              "The prediction market question/statement"
            ],
            type: "string"
          },
          {
            name: "initial_liquidity",
            docs: [
              "Initial liquidity provided to the market"
            ],
            type: "u64"
          },
          {
            name: "end_time",
            docs: [
              "Unix timestamp when the market ends"
            ],
            type: "u64"
          },
          {
            name: "bump",
            docs: [
              "PDA bump seed"
            ],
            type: "u8"
          },
          {
            name: "creation_time",
            docs: [
              "Unix timestamp when the market was created"
            ],
            type: "u64"
          },
          {
            name: "resolvable",
            docs: [
              "Whether the market is resolvable (set by admin/oracle)"
            ],
            type: "bool"
          },
          {
            name: "force_resolve",
            docs: [
              "Whether the market has been force resolved (allows immediate refunds)"
            ],
            type: "bool"
          },
          {
            name: "version",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "MarketCreatedEvent",
      type: {
        kind: "struct",
        fields: [
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "question",
            type: "string"
          },
          {
            name: "initial_liquidity",
            type: "u64"
          },
          {
            name: "end_time",
            type: "u64"
          },
          {
            name: "yes_token_mint",
            type: "pubkey"
          },
          {
            name: "no_token_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "MarketExtension",
      docs: [
        "Extension account for V2 markets with custom odds and oracle",
        "Only created when creator specifies custom settings"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "market_id",
            docs: [
              "Market ID this extension belongs to"
            ],
            type: "u64"
          },
          {
            name: "initial_yes_odds_bps",
            docs: [
              "Initial YES odds in basis points (e.g., 7000 = 70% YES)"
            ],
            type: "u16"
          },
          {
            name: "oracle",
            docs: [
              "Custom oracle for this market (if different from global)"
            ],
            type: "pubkey"
          },
          {
            name: "bump",
            docs: [
              "PDA bump"
            ],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "MarketResolvableUpdated",
      docs: [
        "Event emitted when market resolvable status is updated"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "market_id",
            docs: [
              "Market ID"
            ],
            type: "u64"
          },
          {
            name: "resolvable",
            docs: [
              "New resolvable status"
            ],
            type: "bool"
          }
        ]
      }
    },
    {
      name: "MarketResolvableV3Event",
      type: {
        kind: "struct",
        fields: [
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "market_id",
            type: "u64"
          },
          {
            name: "resolvable",
            type: "bool"
          }
        ]
      }
    },
    {
      name: "MarketV2CreatedEvent",
      type: {
        kind: "struct",
        fields: [
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "market_id",
            type: "u64"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "question",
            type: "string"
          },
          {
            name: "initial_liquidity",
            type: "u64"
          },
          {
            name: "end_time",
            type: "u64"
          },
          {
            name: "version",
            type: "u8"
          },
          {
            name: "has_extension",
            type: "bool"
          },
          {
            name: "yes_odds_bps",
            type: "u16"
          },
          {
            name: "oracle",
            type: {
              option: "pubkey"
            }
          }
        ]
      }
    },
    {
      name: "MarketV2ResolvableUpdated",
      type: {
        kind: "struct",
        fields: [
          {
            name: "market_id",
            type: "u64"
          },
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "resolvable",
            type: "bool"
          },
          {
            name: "tokens_created",
            type: "bool"
          },
          {
            name: "yes_token_mint",
            type: "pubkey"
          },
          {
            name: "no_token_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "MarketV3",
      docs: [
        "V3 Market (Parimutuel) where two sides bet against each other in separate pots",
        "Winner side takes all reserves from both pots"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "id",
            docs: [
              "Unique identifier for this market"
            ],
            type: "u64"
          },
          {
            name: "resolved",
            docs: [
              "Whether the market has been resolved"
            ],
            type: "bool"
          },
          {
            name: "yes_pot_reserve",
            docs: [
              "Total collateral in YES pot"
            ],
            type: "u64"
          },
          {
            name: "no_pot_reserve",
            docs: [
              "Total collateral in NO pot"
            ],
            type: "u64"
          },
          {
            name: "creator",
            docs: [
              "Market creator"
            ],
            type: "pubkey"
          },
          {
            name: "creator_side",
            docs: [
              "Which side creator is backing"
            ],
            type: {
              defined: {
                name: "TokenSide"
              }
            }
          },
          {
            name: "creator_initial_amount",
            docs: [
              "Initial amount creator deposited"
            ],
            type: "u64"
          },
          {
            name: "creator_side_cap",
            docs: [
              "Maximum liquidity allowed on creator's side"
            ],
            type: "u64"
          },
          {
            name: "yes_tokens_issued",
            docs: [
              "Total YES tokens issued"
            ],
            type: "u64"
          },
          {
            name: "no_tokens_issued",
            docs: [
              "Total NO tokens issued"
            ],
            type: "u64"
          },
          {
            name: "collateral_token",
            docs: [
              "Collateral token mint"
            ],
            type: "pubkey"
          },
          {
            name: "yes_token_mint",
            docs: [
              "YES token mint"
            ],
            type: "pubkey"
          },
          {
            name: "no_token_mint",
            docs: [
              "NO token mint"
            ],
            type: "pubkey"
          },
          {
            name: "winning_token_id",
            docs: [
              "Winning side after resolution"
            ],
            type: {
              defined: {
                name: "WinningToken"
              }
            }
          },
          {
            name: "creator_fee_treasury",
            docs: [
              "Creator's fee treasury"
            ],
            type: "pubkey"
          },
          {
            name: "question",
            docs: [
              "Market question"
            ],
            type: "string"
          },
          {
            name: "end_time",
            docs: [
              "Market end timestamp"
            ],
            type: "u64"
          },
          {
            name: "creation_time",
            docs: [
              "Market creation timestamp"
            ],
            type: "u64"
          },
          {
            name: "resolvable",
            docs: [
              "Whether market is resolvable (set by oracle)"
            ],
            type: "bool"
          },
          {
            name: "bump",
            docs: [
              "PDA bump"
            ],
            type: "u8"
          },
          {
            name: "max_pot_ratio",
            docs: [
              "Maximum pot ratio allowed (in basis points, e.g., 10000 = 1:1, 100000 = 10:1)"
            ],
            type: "u32"
          }
        ]
      }
    },
    {
      name: "MarketV3CreatedEvent",
      type: {
        kind: "struct",
        fields: [
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "market_id",
            type: "u64"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "question",
            type: "string"
          },
          {
            name: "initial_amount",
            type: "u64"
          },
          {
            name: "creator_side_amount",
            type: "u64"
          },
          {
            name: "opposing_side_amount",
            type: "u64"
          },
          {
            name: "creator_side",
            type: {
              defined: {
                name: "TokenSide"
              }
            }
          },
          {
            name: "creator_side_cap",
            type: "u64"
          },
          {
            name: "end_time",
            type: "u64"
          },
          {
            name: "max_pot_ratio",
            type: "u32"
          },
          {
            name: "has_extension",
            type: "bool"
          },
          {
            name: "odds_bps",
            type: "u16"
          },
          {
            name: "oracle",
            type: {
              option: "pubkey"
            }
          }
        ]
      }
    },
    {
      name: "MarketV3Extension",
      docs: [
        "Extension account for V3 markets with custom odds and oracle",
        "Only created when creator specifies custom settings"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "market_id",
            docs: [
              "Market ID this extension belongs to"
            ],
            type: "u64"
          },
          {
            name: "odds_bps",
            docs: [
              "Odds in basis points for creator's side (e.g., 7000 = 70%)"
            ],
            type: "u16"
          },
          {
            name: "oracle",
            docs: [
              "Custom oracle for this market (if different from global)"
            ],
            type: "pubkey"
          },
          {
            name: "bump",
            docs: [
              "PDA bump"
            ],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "MintDecisionTokensEvent",
      docs: [
        "Event emitted when decision tokens are minted"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "buyer",
            docs: [
              "Public key of the token buyer"
            ],
            type: "pubkey"
          },
          {
            name: "market",
            docs: [
              "Public key of the prediction market"
            ],
            type: "pubkey"
          },
          {
            name: "amount",
            docs: [
              "Amount of collateral tokens provided"
            ],
            type: "u64"
          },
          {
            name: "tokens_minted",
            docs: [
              "Amount of decision tokens minted"
            ],
            type: "u64"
          },
          {
            name: "buy_yes_token",
            docs: [
              "Whether YES tokens were bought (true) or NO tokens (false)"
            ],
            type: "bool"
          },
          {
            name: "creator_fee",
            docs: [
              "Amount of creator fee"
            ],
            type: "u64"
          },
          {
            name: "admin_fee",
            docs: [
              "Amount of admin fee"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "PriceGetterEvent",
      type: {
        kind: "struct",
        fields: [
          {
            name: "yes_price",
            type: "u64"
          },
          {
            name: "no_price",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RedeemPositionEvent",
      docs: [
        "Event emitted when position is redeemed"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "redeemer",
            docs: [
              "Public key of the position redeemer"
            ],
            type: "pubkey"
          },
          {
            name: "market",
            docs: [
              "Public key of the prediction market"
            ],
            type: "pubkey"
          },
          {
            name: "winning_token_amount",
            docs: [
              "Amount of winning tokens redeemed"
            ],
            type: "u64"
          },
          {
            name: "collateral_redeemed",
            docs: [
              "Amount of collateral tokens received"
            ],
            type: "u64"
          },
          {
            name: "winning_token_type",
            docs: [
              "Type of winning token (YES or NO)"
            ],
            type: {
              defined: {
                name: "WinningToken"
              }
            }
          }
        ]
      }
    },
    {
      name: "RedeemV3PositionEvent",
      type: {
        kind: "struct",
        fields: [
          {
            name: "redeemer",
            type: "pubkey"
          },
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "tokens_burned",
            type: "u64"
          },
          {
            name: "payout",
            type: "u64"
          },
          {
            name: "winning_side",
            type: {
              defined: {
                name: "WinningToken"
              }
            }
          },
          {
            name: "creator_fee",
            type: "u64"
          },
          {
            name: "admin_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SetFeeEvent",
      docs: [
        "Event emitted when the protocol fee is updated"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "fee",
            docs: [
              "The new fee value (between 0-10000, representing 0-100%)"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SettleMarketEvent",
      docs: [
        "Event emitted when market is settled"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "market",
            docs: [
              "Public key of the prediction market"
            ],
            type: "pubkey"
          },
          {
            name: "yes_winner",
            docs: [
              "Whether YES tokens won (true) or NO tokens (false)"
            ],
            type: "bool"
          }
        ]
      }
    },
    {
      name: "SettleMarketV3Event",
      type: {
        kind: "struct",
        fields: [
          {
            name: "market",
            type: "pubkey"
          },
          {
            name: "yes_winner",
            type: "bool"
          },
          {
            name: "yes_pot_reserve",
            type: "u64"
          },
          {
            name: "no_pot_reserve",
            type: "u64"
          },
          {
            name: "total_reserves",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TokenSide",
      docs: [
        "Which side of the market"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Yes"
          },
          {
            name: "No"
          }
        ]
      }
    },
    {
      name: "WinningToken",
      docs: [
        "Represents the possible winning token types for a market"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "None"
          },
          {
            name: "Yes"
          },
          {
            name: "No"
          }
        ]
      }
    }
  ]
};

// src/idl/index.ts
var DEBUG = process.env.PNP_DEBUG === "1";
var PNP_IDL = pnp_exchange_default;
var PNP_PROGRAM_ID = new import_web3.PublicKey(
  PNP_IDL.address ?? (() => {
    throw new Error("IDL missing address field");
  })()
);
var idlCoder = new import_anchor.BorshCoder(PNP_IDL);
function buildIdlIx(ixName, accounts, args = [], programId) {
  const ixDef = PNP_IDL.instructions?.find((ix) => ix.name === ixName);
  if (!ixDef) throw new Error(`Instruction not found in IDL: ${ixName}`);
  if (DEBUG) {
    console.log(`Building instruction: ${ixName}`);
    console.log(
      `Instruction args:`,
      JSON.stringify(
        args.map((v) => {
          if (v && typeof v === "object") {
            if (typeof v.toString === "function" && v.constructor?.name === "BN") {
              return { __bn: v.toString(10) };
            }
            if (typeof v.toBase58 === "function") {
              return { __pubkey: v.toBase58() };
            }
            if (v instanceof Uint8Array) {
              return { __bytes: Buffer.from(v).toString("hex") };
            }
          }
          if (typeof v === "bigint") return v.toString();
          return v;
        }),
        null,
        2
      )
    );
    console.log(`IDL definition:`, JSON.stringify(ixDef.args, null, 2));
  }
  try {
    if (DEBUG) {
      console.log(`Accounts for ${ixName} (IDL order):`);
      for (const acc of ixDef.accounts) {
        const name = acc.name;
        const pk = accounts[name];
        console.log(`  ${name}: ${pk ? pk.toBase58() : "(missing)"}`);
      }
    }
  } catch (_) {
  }
  if (ixDef.args && ixDef.args.length > 0) {
    if (DEBUG) {
      console.log("Checking argument types against IDL specification...");
      for (let i = 0; i < Math.min(args.length, ixDef.args.length); i++) {
        const argDef = ixDef.args[i];
        if (!argDef) continue;
        const argValue = args[i];
        console.log(
          `Arg ${i} (${argDef.name}): Expected type '${argDef.type}', got '${typeof argValue}' with value:`,
          typeof argValue === "bigint" ? argValue.toString() : argValue
        );
      }
    }
  }
  try {
    let namedArgs = args;
    if (Array.isArray(args)) {
      namedArgs = {};
      for (let i = 0; i < (ixDef.args?.length ?? 0); i++) {
        const def = ixDef.args[i];
        if (!def) continue;
        namedArgs[def.name] = args[i];
      }
      if (DEBUG) {
        console.log(`Mapped positional args to named args:`, JSON.stringify(namedArgs, (key, value) => {
          if (value && typeof value === "object") {
            if (typeof value.toString === "function" && value.constructor?.name === "BN") {
              return { __bn: value.toString(10) };
            }
            if (typeof value.toBase58 === "function") {
              return { __pubkey: value.toBase58() };
            }
            if (value instanceof Uint8Array) {
              return { __bytes: Buffer.from(value).toString("hex") };
            }
          }
          if (typeof value === "bigint") return value.toString();
          return value;
        }, 2));
      }
    }
    const data = idlCoder.instruction.encode(ixName, namedArgs);
    if (DEBUG) {
      console.log(`Instruction data encoded successfully, length: ${data.length} bytes`);
      console.log(`First 20 bytes: ${Buffer.from(data).toString("hex").substring(0, 40)}...`);
    }
    try {
      if (DEBUG) {
        const buf = Buffer.from(data);
        const off = 8;
        const readU64LE = (b, o) => BigInt(b.readUInt32LE(o)) + (BigInt(b.readUInt32LE(o + 4)) << 32n);
        if (ixName === "mint_decision_tokens") {
          const amountLE = readU64LE(buf, off);
          const buyFlag = buf[off + 8] === 1;
          const minimumOutLE = readU64LE(buf, off + 9);
          console.log(
            `[buildIdlIx:${ixName}] Encoded fields -> amount(u64): ${amountLE.toString()}, buy_yes_token(bool): ${buyFlag}, minimum_out(u64): ${minimumOutLE.toString()}`
          );
        }
        if (ixName === "burn_decision_tokens") {
          const amountLE = readU64LE(buf, off);
          const burnFlag = buf[off + 8] === 1;
          console.log(
            `[buildIdlIx:${ixName}] Encoded fields -> amount(u64): ${amountLE.toString()}, burn_yes_token(bool): ${burnFlag}`
          );
        }
      }
    } catch (e) {
      if (DEBUG) console.warn(`[buildIdlIx:${ixName}] Post-encode field inspection failed:`, e?.message ?? String(e));
    }
    const programIdToUse = programId || PNP_PROGRAM_ID;
    return new import_web3.TransactionInstruction({ programId: programIdToUse, keys: constructAccountMetas(ixDef, accounts), data });
  } catch (err) {
    if (DEBUG) console.error(`Failed to encode instruction data: ${err.message || err}`);
    throw err;
  }
}
function constructAccountMetas(ixDef, accounts) {
  const metas = [];
  for (const acc of ixDef.accounts) {
    const a = acc;
    const name = a.name;
    const optional = Boolean(a.optional);
    const pubkey = accounts[name];
    if (!pubkey) {
      if (optional) {
        continue;
      }
      throw new Error(`Missing account for ${ixDef.name}: ${name}`);
    }
    const isSigner = Boolean(a.signer);
    const isWritable = Boolean(a.writable);
    metas.push({ pubkey, isSigner, isWritable });
  }
  return metas;
}
function decodeAccount(accountName, data) {
  return idlCoder.accounts.decode(accountName, data);
}

// src/platform/client.ts
var MAINNET_PROGRAM_ID = PNP_PROGRAM_ID;
var DEVNET_PROGRAM_ID = new import_web32.PublicKey("pnpkv2qnh4bfpGvTugGDSEhvZC7DP4pVxTuDykV3BGz");
function isDevnetRpc(rpcUrl) {
  const url = rpcUrl.toLowerCase();
  return url.includes("devnet") || url.includes("dev.") || url.includes(":8899");
}
var Client = class {
  connection;
  programId;
  commitment;
  logger;
  isDevnet;
  constructor(cfg) {
    this.commitment = cfg.commitment ?? "confirmed";
    this.connection = new import_web32.Connection(cfg.rpcUrl, {
      commitment: this.commitment,
      httpHeaders: cfg.httpHeaders
    });
    this.isDevnet = isDevnetRpc(cfg.rpcUrl);
    this.programId = this.isDevnet ? DEVNET_PROGRAM_ID : MAINNET_PROGRAM_ID;
    this.logger = cfg.logger ?? console;
    if (this.isDevnet) {
      this.logger.info?.(`[PNP SDK] Using DEVNET program: ${DEVNET_PROGRAM_ID.toBase58()}`);
    }
  }
  fail(code, message, details) {
    this.logger.error?.(code, message, details);
    return new TransportError(`${code}: ${message}`, details);
  }
};

// src/platform/wallet.ts
var import_web33 = require("@solana/web3.js");
var NodeKeypairSigner = class {
  constructor(keypair) {
    this.keypair = keypair;
  }
  get publicKey() {
    return this.keypair.publicKey;
  }
  async signTransaction(tx) {
    if (tx instanceof import_web33.VersionedTransaction) {
      tx.sign([this.keypair]);
      return tx;
    }
    tx.partialSign(this.keypair);
    return tx;
  }
};

// src/modules/market.ts
var import_web36 = require("@solana/web3.js");
var import_zod = require("zod");

// src/instructions/idl_builders.ts
var import_bn = __toESM(require("bn.js"), 1);
var DEBUG2 = process.env.PNP_DEBUG === "1";
function buildCreateMarketIxIdl(accounts, args, programId) {
  if (DEBUG2) {
    console.log("Building create_market_v2 instruction with args:", JSON.stringify({
      question: args.question,
      initial_liquidity: args.initial_liquidity.toString(),
      end_time: args.end_time.toString(),
      creator: args.creator?.toBase58() || accounts.creator?.toBase58() || accounts.payer?.toBase58(),
      yes_odds_bps: args.yes_odds_bps,
      oracle: args.oracle?.toBase58()
    }));
    console.log("Accounts being passed to create_market_v2:");
    Object.entries(accounts).forEach(([name, pubkey]) => {
      console.log(`  ${name}: ${pubkey?.toString() || "null"}`);
    });
  }
  const question = args.question;
  const initial_liquidity = new import_bn.default(args.initial_liquidity.toString());
  const end_time = new import_bn.default(args.end_time.toString());
  if (DEBUG2) {
    console.log("Prepared arguments for IDL encoding:");
    console.log(`  question: ${question} (type: ${typeof question})`);
    console.log(`  initial_liquidity: ${initial_liquidity.toString()} (type: ${typeof initial_liquidity})`);
    console.log(`  end_time: ${end_time.toString()} (type: ${typeof end_time})`);
  }
  const creator = args.creator || accounts.creator || accounts.payer;
  if (!creator) {
    throw new Error("Creator is required for create_market_v2");
  }
  if (DEBUG2) {
    console.log(`  creator: ${creator.toBase58()} (type: ${typeof creator})`);
    console.log(`  yes_odds_bps: ${args.yes_odds_bps ?? "null (default 5000)"}`);
    console.log(`  oracle: ${args.oracle?.toBase58() ?? "null (default global oracle)"}`);
  }
  return buildIdlIx(
    "create_market_v2",
    accounts,
    [
      question,
      initial_liquidity,
      end_time,
      creator,
      args.yes_odds_bps ?? null,
      args.oracle ?? null
    ],
    programId
  );
}
function buildMintDecisionTokensIx(accounts, args, programId) {
  const amount = new import_bn.default(args.amount.toString());
  const minimum_out = new import_bn.default(args.minimum_out.toString());
  try {
    if (DEBUG2) {
      console.log("[buildMintDecisionTokensIx] amount:", args.amount.toString?.() ?? String(args.amount));
      console.log("[buildMintDecisionTokensIx] minimum_out:", args.minimum_out.toString?.() ?? String(args.minimum_out));
      console.log("[buildMintDecisionTokensIx] BN amount:", amount.toString(10));
      console.log("[buildMintDecisionTokensIx] BN minimum_out:", minimum_out.toString(10));
    }
  } catch {
  }
  return buildIdlIx("mint_decision_tokens", accounts, [amount, args.buy_yes_token, minimum_out], programId);
}
function buildBurnDecisionTokensIx(accounts, args, programId) {
  const amount = new import_bn.default(args.amount.toString());
  try {
    if (DEBUG2) {
      console.log("[buildBurnDecisionTokensIx] amount:", args.amount.toString?.() ?? String(args.amount));
      console.log("[buildBurnDecisionTokensIx] BN amount:", amount.toString(10));
    }
  } catch {
  }
  return buildIdlIx("burn_decision_tokens", accounts, [amount, args.burn_yes_token], programId);
}
function buildClaimCreatorFeeIx(accounts, programId) {
  return buildIdlIx("claim_creator_fee", accounts, [], programId);
}
function buildCreatorRefundIx(accounts, programId) {
  return buildIdlIx("creator_refund", accounts, [], programId);
}
function buildCreatorRefundV2Ix(accounts, programId) {
  return buildIdlIx("creator_refund_v2", accounts, [], programId);
}
function buildCreatorRefundV3Ix(accounts, programId) {
  return buildIdlIx("creator_refund_v3", accounts, [], programId);
}
function buildRedeemPositionV2Ix(accounts, programId) {
  return buildIdlIx("redeem_position_v2", accounts, [], programId);
}
function buildRedeemV3PositionIx(accounts, programId) {
  return buildIdlIx("redeem_v3_position", accounts, [], programId);
}
function buildSetMarketResolvableV2Ix(accounts, args, programId) {
  const market_id = new import_bn.default(args.market_id.toString());
  const resolvable = args.resolvable;
  const force_resolve = args.force_resolve !== void 0 ? args.force_resolve : null;
  return buildIdlIx("set_market_resolvable_v2", accounts, [market_id, resolvable, force_resolve], programId);
}
function buildSetMarketResolvableV3Ix(accounts, args, programId) {
  const resolvable = args.resolvable;
  return buildIdlIx("set_market_resolvable_v3", accounts, [resolvable], programId);
}

// src/platform/tx.ts
var import_web34 = require("@solana/web3.js");
async function buildAndSendV0(client, signer, ixs, opts = {}) {
  const latest = await client.connection.getLatestBlockhash({ commitment: client.commitment });
  const preIxs = [];
  if (opts.computeUnitLimit) preIxs.push(import_web34.ComputeBudgetProgram.setComputeUnitLimit({ units: opts.computeUnitLimit }));
  if (opts.computeUnitPriceMicroLamports) preIxs.push(import_web34.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: opts.computeUnitPriceMicroLamports }));
  const msg = new import_web34.TransactionMessage({
    payerKey: signer.publicKey,
    recentBlockhash: latest.blockhash,
    instructions: [...preIxs, ...ixs]
  }).compileToV0Message(opts.addressLookupTables);
  const tx = new import_web34.VersionedTransaction(msg);
  await signer.signTransaction(tx);
  if (opts.simulate) {
    const sim = await client.connection.simulateTransaction(tx, { sigVerify: true });
    return { simulated: sim, signature: void 0 };
  }
  const sig = await client.connection.sendTransaction(tx, { skipPreflight: false, maxRetries: 3, preflightCommitment: client.commitment });
  return { signature: sig };
}

// src/instructions/pdas.ts
var import_web35 = require("@solana/web3.js");
var import_spl_token = require("@solana/spl-token");
function deriveGlobalConfigPda(programId) {
  return import_web35.PublicKey.findProgramAddressSync([Buffer.from("global_config")], programId);
}
function deriveCreatorFeeTreasuryPda(creator, programId, collateralMint) {
  return import_web35.PublicKey.findProgramAddressSync(
    [Buffer.from("creator_fee_treasury"), creator.toBuffer(), collateralMint.toBuffer()],
    programId
  );
}
function deriveAta(owner, mint, allowOwnerOffCurve = false, tokenProgramId = import_spl_token.TOKEN_PROGRAM_ID, ataProgramId = import_spl_token.ASSOCIATED_TOKEN_PROGRAM_ID) {
  return (0, import_spl_token.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, tokenProgramId, ataProgramId);
}
function u64LeBuffer(n) {
  const buf = Buffer.alloc(8);
  let x = n;
  for (let i = 0; i < 8; i++) {
    buf[i] = Number(x & 0xffn);
    x >>= 8n;
  }
  return buf;
}
function deriveYesTokenMint(globalId, programId) {
  return import_web35.PublicKey.findProgramAddressSync([
    Buffer.from("yes_token"),
    u64LeBuffer(globalId)
  ], programId);
}
function deriveNoTokenMint(globalId, programId) {
  return import_web35.PublicKey.findProgramAddressSync([
    Buffer.from("no_token"),
    u64LeBuffer(globalId)
  ], programId);
}
function deriveTokenMetadataPda(mint, metadataProgramId) {
  return import_web35.PublicKey.findProgramAddressSync([
    Buffer.from("metadata"),
    metadataProgramId.toBuffer(),
    mint.toBuffer()
  ], metadataProgramId);
}

// src/modules/market.ts
var import_spl_token2 = require("@solana/spl-token");
var DEBUG3 = process.env.PNP_DEBUG === "1";
var DEFAULT_COLLATERAL_MINT = new import_web36.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
var CreateMarketSchema = import_zod.z.object({
  baseMint: import_zod.z.instanceof(import_web36.PublicKey).optional(),
  quoteMint: import_zod.z.instanceof(import_web36.PublicKey).optional(),
  question: import_zod.z.string().optional(),
  initialLiquidity: import_zod.z.bigint().optional(),
  endTime: import_zod.z.bigint().optional(),
  tickSize: import_zod.z.bigint().optional(),
  lotSize: import_zod.z.bigint().optional()
});
var MarketModule = class {
  constructor(client, signer) {
    this.client = client;
    this.signer = signer;
  }
  async createMarket(params) {
    const p = CreateMarketSchema.parse(params);
    if (!p.question || !p.initialLiquidity || !p.endTime) {
      throw new Error("createMarket now requires question, initialLiquidity, and endTime. The legacy v1 path has been removed.");
    }
    const collateral = p.baseMint ?? DEFAULT_COLLATERAL_MINT;
    return this.createMarketDerived({
      question: p.question,
      initialLiquidity: p.initialLiquidity,
      endTime: p.endTime,
      collateralMint: collateral
    });
  }
  // IDL-backed create market allowing explicit accounts from the pnp.exchange IDL
  async createMarketIdl(accounts, args) {
    const ix = buildCreateMarketIxIdl(accounts, args, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  // High-level helper: derive all accounts and create market (V2)
  async createMarketDerived(params) {
    const { question, initialLiquidity, endTime } = params;
    const collateralMint = params.collateralMint ?? DEFAULT_COLLATERAL_MINT;
    const [globalConfig] = deriveGlobalConfigPda(this.client.programId);
    const ai = await this.client.connection.getAccountInfo(globalConfig, this.client.commitment);
    if (!ai) throw new Error("global_config not initialized on-chain");
    const globalCfg = decodeAccount("GlobalConfig", ai.data);
    if (DEBUG3) {
      try {
        console.log("GlobalConfig account data:", JSON.stringify(globalCfg, null, 2));
      } catch {
      }
    }
    let globalId;
    if (globalCfg.globalId) {
      globalId = BigInt(globalCfg.globalId.toString());
    } else if (globalCfg.global_id) {
      globalId = BigInt(globalCfg.global_id.toString());
    } else {
      const keys = Object.keys(globalCfg);
      if (DEBUG3) console.log("Available keys in GlobalConfig:", keys);
      const idField = keys.find(
        (k) => typeof globalCfg[k]?.toNumber === "function" || typeof globalCfg[k]?.toString === "function" || typeof globalCfg[k] === "number"
      );
      if (idField) {
        if (DEBUG3) console.log(`Using ${idField} as the global ID field`);
        globalId = BigInt(globalCfg[idField].toString());
      } else {
        throw new Error(`Could not find global ID in GlobalConfig account. Available fields: ${keys.join(", ")}`);
      }
    }
    const gidLe = Buffer.alloc(8);
    gidLe.writeBigUInt64LE(globalId);
    const [market] = import_web36.PublicKey.findProgramAddressSync(
      [Buffer.from("market-v2"), gidLe],
      this.client.programId
    );
    const [marketExtension] = import_web36.PublicKey.findProgramAddressSync(
      [Buffer.from("market_ext"), gidLe],
      this.client.programId
    );
    const payer = this.signer.publicKey;
    const creator = payer;
    const payerCollateralTokenAccount = deriveAta(payer, collateralMint);
    const marketReserveVault = deriveAta(market, collateralMint, true);
    const [creatorFeeTreasury] = deriveCreatorFeeTreasuryPda(creator, this.client.programId, collateralMint);
    const accounts = {
      payer,
      creator,
      market,
      market_extension: marketExtension,
      // Always include (program may expect it)
      global_config: globalConfig,
      collateral_token_mint: collateralMint,
      payer_collateral_token_account: payerCollateralTokenAccount,
      market_reserve_vault: marketReserveVault,
      creator_fee_treasury: creatorFeeTreasury,
      token_program: import_spl_token2.TOKEN_PROGRAM_ID,
      associated_token_program: import_spl_token2.ASSOCIATED_TOKEN_PROGRAM_ID,
      system_program: import_web36.SystemProgram.programId
    };
    const ix = buildCreateMarketIxIdl(accounts, {
      question,
      initial_liquidity: initialLiquidity,
      end_time: endTime,
      creator,
      // Pass the creator explicitly
      yes_odds_bps: 5e3
      // Default 50/50 odds - REQUIRED to initialize market_extension
    }, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 4e5
    });
    return {
      signature: res.signature,
      market
    };
  }
  // ===== Fetchers =====
  async fetchGlobalConfig() {
    const [globalConfig] = deriveGlobalConfigPda(this.client.programId);
    const ai = await this.client.connection.getAccountInfo(globalConfig, this.client.commitment);
    if (!ai) throw new Error("global_config not found");
    const acc = decodeAccount("GlobalConfig", ai.data);
    return { publicKey: globalConfig, account: acc };
  }
  async fetchMarket(market) {
    const ai = await this.client.connection.getAccountInfo(market, this.client.commitment);
    if (!ai) throw new Error("market account not found");
    const acc = decodeAccount("Market", ai.data);
    return { publicKey: market, account: acc };
  }
  // ===== Set Market Resolvable (V2) =====
  /**
   *  DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
   * It will NOT work on mainnet. Use this only for development and testing.
   */
  async setMarketResolvableIdl(accounts, args) {
    const ix = buildSetMarketResolvableV2Ix(accounts, args);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    if (!res.signature) {
      throw new Error("Transaction failed: No signature returned");
    }
    return { signature: res.signature };
  }
  /**
   * Set market resolvable status for V2 markets.
   * 
   *  DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
   * It will NOT work on mainnet. Use this only for development and testing.
   * 
   * @param params - Parameters for setting market resolvable status
   * @param params.market - Market public key
   * @param params.resolvable - New resolvable status (true/false)
   * @param params.forceResolve - Optional: force resolve (allow immediate refunds)
   * @returns Transaction signature
   */
  async setMarketResolvable(params) {
    const { market, resolvable, forceResolve } = params;
    const { account: marketAccount } = await this.fetchMarket(market);
    let marketId;
    if (marketAccount.id !== void 0 && marketAccount.id !== null) {
      marketId = BigInt(marketAccount.id.toString());
    } else if (marketAccount.market_id !== void 0) {
      marketId = BigInt(marketAccount.market_id.toString());
    } else {
      throw new Error("Could not extract market_id from market account. Market account missing 'id' field.");
    }
    if (marketId === 0n) {
      throw new Error("Market ID is zero, which is invalid");
    }
    const [globalConfig] = deriveGlobalConfigPda(this.client.programId);
    const globalConfigInfo = await this.client.connection.getAccountInfo(globalConfig, this.client.commitment);
    if (!globalConfigInfo) throw new Error("global_config not initialized on-chain");
    const collateralTokenMint = new import_web36.PublicKey(marketAccount.collateral_token || marketAccount.collateralToken);
    const creator = new import_web36.PublicKey(marketAccount.creator);
    const [yesTokenMint] = deriveYesTokenMint(marketId, this.client.programId);
    const [noTokenMint] = deriveNoTokenMint(marketId, this.client.programId);
    const creatorYesTokenAccount = deriveAta(creator, yesTokenMint);
    const creatorNoTokenAccount = deriveAta(creator, noTokenMint);
    const TOKEN_METADATA_PROGRAM_ID = new import_web36.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
    const [yesMetadata] = deriveTokenMetadataPda(yesTokenMint, TOKEN_METADATA_PROGRAM_ID);
    const [noMetadata] = deriveTokenMetadataPda(noTokenMint, TOKEN_METADATA_PROGRAM_ID);
    const collateralMintInfo = await this.client.connection.getAccountInfo(collateralTokenMint, this.client.commitment);
    if (!collateralMintInfo) throw new Error("collateral_token_mint not found");
    const tokenProgram = collateralMintInfo.owner.equals(import_spl_token2.TOKEN_2022_PROGRAM_ID) ? import_spl_token2.TOKEN_2022_PROGRAM_ID : import_spl_token2.TOKEN_PROGRAM_ID;
    const marketIdBuffer = Buffer.alloc(8);
    marketIdBuffer.writeBigUInt64LE(marketId);
    const [marketExtension] = import_web36.PublicKey.findProgramAddressSync(
      [Buffer.from("market_ext"), marketIdBuffer],
      this.client.programId
    );
    const accounts = {
      authority: this.signer.publicKey,
      global_config: globalConfig,
      market,
      market_extension: marketExtension,
      // Always include (optional in IDL but position depends on it)
      collateral_token_mint: collateralTokenMint,
      yes_token_mint: yesTokenMint,
      no_token_mint: noTokenMint,
      creator,
      creator_yes_token_account: creatorYesTokenAccount,
      creator_no_token_account: creatorNoTokenAccount,
      token_metadata_program: TOKEN_METADATA_PROGRAM_ID,
      yes_metadata: yesMetadata,
      no_metadata: noMetadata,
      token_program: tokenProgram,
      associated_token_program: import_spl_token2.ASSOCIATED_TOKEN_PROGRAM_ID,
      system_program: import_web36.SystemProgram.programId,
      rent: new import_web36.PublicKey("SysvarRent111111111111111111111111111111111")
    };
    const ix = buildSetMarketResolvableV2Ix(accounts, {
      market_id: marketId,
      resolvable,
      force_resolve: forceResolve
    }, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    if (!res.signature) {
      throw new Error("Transaction failed: No signature returned");
    }
    return { signature: res.signature };
  }
  // ===== Set Market Resolvable (V3/P2P) =====
  /**
   *  DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
   * It will NOT work on mainnet. Use this only for development and testing.
   */
  async setMarketResolvableP2pIdl(accounts, args) {
    const ix = buildSetMarketResolvableV3Ix(accounts, args);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    if (!res.signature) {
      throw new Error("Transaction failed: No signature returned");
    }
    return { signature: res.signature };
  }
  /**
   * Set market resolvable status for V3/P2P markets.
   * 
   *  DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
   * It will NOT work on mainnet. Use this only for development and testing.
   * 
   * @param params - Parameters for setting market resolvable status
   * @param params.market - Market public key
   * @param params.resolvable - New resolvable status (true/false)
   * @returns Transaction signature
   */
  async setMarketResolvableP2p(params) {
    const { market, resolvable } = params;
    const [globalConfig] = deriveGlobalConfigPda(this.client.programId);
    const globalConfigInfo = await this.client.connection.getAccountInfo(globalConfig, this.client.commitment);
    if (!globalConfigInfo) throw new Error("global_config not initialized on-chain");
    const accounts = {
      authority: this.signer.publicKey,
      global_config: globalConfig,
      market
    };
    const ix = buildSetMarketResolvableV3Ix(accounts, {
      resolvable
    }, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    if (!res.signature) {
      throw new Error("Transaction failed: No signature returned");
    }
    return { signature: res.signature };
  }
};

// src/modules/trading.ts
var import_web38 = require("@solana/web3.js");
var import_zod2 = require("zod");

// src/instructions/trading.ts
var import_web37 = require("@solana/web3.js");
function buildTradeIx(params) {
  const { trader, market, side } = params;
  const disc = 1;
  const sideFlag = side === "buy" ? 0 : 1;
  const data = Buffer.from([disc, sideFlag]);
  const keys = [
    { pubkey: trader, isSigner: true, isWritable: true },
    { pubkey: market, isSigner: false, isWritable: true }
  ];
  return new import_web37.TransactionInstruction({ keys, programId: PNP_PROGRAM_ID, data });
}

// src/modules/trading.ts
var import_spl_token3 = require("@solana/spl-token");
var TradeSchema = import_zod2.z.object({
  market: import_zod2.z.instanceof(import_web38.PublicKey),
  side: import_zod2.z.union([import_zod2.z.literal("buy"), import_zod2.z.literal("sell")]),
  price: import_zod2.z.bigint(),
  size: import_zod2.z.bigint()
});
var TradingModule = class _TradingModule {
  constructor(client, signer) {
    this.client = client;
    this.signer = signer;
  }
  // Anchor account discriminators are 8 bytes at the start of account data.
  // Allow overriding via env var MARKET_CREATED_V3_DISCRIMINATOR (hex string) for flexibility.
  static MARKET_CREATED_V3_DISCRIMINATOR = (() => {
    const hex = process.env.MARKET_CREATED_V3_DISCRIMINATOR || "488657404fa709bd";
    try {
      return Buffer.from(hex, "hex");
    } catch {
      return Buffer.from("488657404fa709bd", "hex");
    }
  })();
  decodeMarketAny(data) {
    const prefix = data.subarray(0, 8);
    if (prefix.equals(_TradingModule.MARKET_CREATED_V3_DISCRIMINATOR)) {
      return decodeAccount("MarketV3", data);
    }
    try {
      return decodeAccount("Market", data);
    } catch {
      return decodeAccount("MarketV3", data);
    }
  }
  async trade(params) {
    const p = TradeSchema.parse(params);
    const ix = buildTradeIx({
      trader: this.signer.publicKey,
      market: p.market,
      side: p.side,
      price: p.price,
      size: p.size
    });
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  // IDL-backed mint of decision tokens (YES/NO) using explicit accounts per IDL
  async mintDecisionTokens(accounts, args) {
    const ix = buildMintDecisionTokensIx(accounts, args, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  // IDL-backed burn of decision tokens for collateral redemption
  async burnDecisionTokens(accounts, args) {
    const ix = buildBurnDecisionTokensIx(accounts, args, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  // ===== Derived helpers =====
  async mintDecisionTokensDerived(params) {
    const { market, amount, buyYesToken, minimumOut } = params;
    try {
      console.log("[mintDecisionTokensDerived] amount:", amount.toString(), "buyYesToken:", buyYesToken, "minimumOut:", minimumOut.toString());
    } catch {
    }
    if (amount <= 0n) throw new Error("amount must be > 0");
    const buyer = this.signer.publicKey;
    const mai = await this.client.connection.getAccountInfo(market, this.client.commitment);
    if (!mai) throw new Error("market account not found");
    const m = this.decodeMarketAny(mai.data);
    const yesTokenMint = new import_web38.PublicKey(m.yesTokenMint ?? m.yes_token_mint);
    const noTokenMint = new import_web38.PublicKey(m.noTokenMint ?? m.no_token_mint);
    const collateralMint = new import_web38.PublicKey(m.collateralToken ?? m.collateral_token);
    const marketCreator = new import_web38.PublicKey(m.creator ?? m.market_creator ?? m.creator);
    const creatorFeeTreasury = new import_web38.PublicKey(m.creatorFeeTreasury ?? m.creator_fee_treasury);
    try {
      const reservesRaw = m.marketReserves ?? m.market_reserves;
      const yesMintedRaw = m.yesTokenSupplyMinted ?? m.yes_token_supply_minted;
      const noMintedRaw = m.noTokenSupplyMinted ?? m.no_token_supply_minted;
      const toBigInt = (v) => {
        if (v === void 0 || v === null) return null;
        if (typeof v === "bigint") return v;
        if (typeof v === "number") return BigInt(v);
        if (typeof v === "string") {
          const isHex = /^[0-9a-fA-F]+$/.test(v);
          try {
            return isHex ? BigInt("0x" + v) : BigInt(v);
          } catch {
            return null;
          }
        }
        return null;
      };
      const reserves = toBigInt(reservesRaw);
      const yesMinted = toBigInt(yesMintedRaw);
      const noMinted = toBigInt(noMintedRaw);
      if (reserves !== null && reserves === 0n) {
        throw new Error("Market has zero reserves; cannot price trade. Recreate/seed the market with initial liquidity.");
      }
      if (yesMinted !== null && noMinted !== null) {
        if (yesMinted === 0n && noMinted === 0n) {
          throw new Error("Market token supplies are uninitialized (YES=0, NO=0); cannot calculate mint output. Seed market first.");
        }
      }
    } catch (prefErr) {
      if (prefErr instanceof Error) throw prefErr;
    }
    const [globalConfig] = deriveGlobalConfigPda(this.client.programId);
    const gai = await this.client.connection.getAccountInfo(globalConfig, this.client.commitment);
    if (!gai) throw new Error("global_config not initialized");
    const g = decodeAccount("GlobalConfig", gai.data);
    const admin = new import_web38.PublicKey(g.admin);
    const [yesAi, noAi, colAi] = await Promise.all([
      this.client.connection.getAccountInfo(yesTokenMint, this.client.commitment),
      this.client.connection.getAccountInfo(noTokenMint, this.client.commitment),
      this.client.connection.getAccountInfo(collateralMint, this.client.commitment)
    ]);
    if (!yesAi || !noAi || !colAi) throw new Error("one or more mint accounts not found");
    const tokenProgramId = yesAi.owner.equals(import_spl_token3.TOKEN_2022_PROGRAM_ID) ? import_spl_token3.TOKEN_2022_PROGRAM_ID : import_spl_token3.TOKEN_PROGRAM_ID;
    const ataProgramId = import_spl_token3.ASSOCIATED_TOKEN_PROGRAM_ID;
    const owners = [yesAi.owner.toBase58(), noAi.owner.toBase58(), colAi.owner.toBase58()];
    if (!(yesAi.owner.equals(noAi.owner) && yesAi.owner.equals(colAi.owner))) {
      throw new Error(`Market mint program mismatch. Owners: YES=${owners[0]}, NO=${owners[1]}, COLLATERAL=${owners[2]}. All mints must share the same token program.`);
    }
    await (0, import_spl_token3.getMint)(this.client.connection, collateralMint, this.client.commitment, tokenProgramId);
    const buyerCollateralTokenAccount = deriveAta(buyer, collateralMint, false, tokenProgramId, ataProgramId);
    const adminCollateralTokenAccount = deriveAta(admin, collateralMint, false, tokenProgramId, ataProgramId);
    const marketReserveVault = deriveAta(market, collateralMint, true, tokenProgramId, ataProgramId);
    const buyerYesTokenAccount = deriveAta(buyer, yesTokenMint, false, tokenProgramId, ataProgramId);
    const buyerNoTokenAccount = deriveAta(buyer, noTokenMint, false, tokenProgramId, ataProgramId);
    const preIxs = [];
    const maybeCreateAta = async (owner, mint, ata, useTokenProgram = tokenProgramId, useAtaProgram = ataProgramId) => {
      const info = await this.client.connection.getAccountInfo(ata, this.client.commitment);
      if (!info) {
        preIxs.push(
          (0, import_spl_token3.createAssociatedTokenAccountInstruction)(
            this.signer.publicKey,
            // payer
            ata,
            owner,
            mint,
            useTokenProgram,
            useAtaProgram
          )
        );
      }
    };
    await maybeCreateAta(buyer, collateralMint, buyerCollateralTokenAccount);
    await maybeCreateAta(admin, collateralMint, adminCollateralTokenAccount);
    await maybeCreateAta(market, collateralMint, marketReserveVault);
    await maybeCreateAta(buyer, yesTokenMint, buyerYesTokenAccount, tokenProgramId, ataProgramId);
    await maybeCreateAta(buyer, noTokenMint, buyerNoTokenAccount, tokenProgramId, ataProgramId);
    const buyerCollateralInfo = await this.client.connection.getTokenAccountBalance(buyerCollateralTokenAccount).catch(() => null);
    if (!buyerCollateralInfo) {
      throw new Error("Buyer collateral token account missing or unreadable");
    }
    const buyerCollateralAmount = BigInt(buyerCollateralInfo.value.amount || "0");
    if (buyerCollateralAmount < amount) {
      throw new Error(`Insufficient collateral balance: have ${buyerCollateralInfo.value.uiAmountString}, need ${(Number(amount) / 1e6).toFixed(6)}`);
    }
    const accounts = {
      buyer,
      admin,
      market_creator: marketCreator,
      market,
      global_config: globalConfig,
      yes_token_mint: yesTokenMint,
      no_token_mint: noTokenMint,
      buyer_yes_token_account: buyerYesTokenAccount,
      buyer_no_token_account: buyerNoTokenAccount,
      market_reserve_vault: marketReserveVault,
      collateral_token_mint: collateralMint,
      buyer_collateral_token_account: buyerCollateralTokenAccount,
      admin_collateral_token_account: adminCollateralTokenAccount,
      creator_fee_treasury: creatorFeeTreasury,
      token_program: tokenProgramId,
      associated_token_program: ataProgramId,
      system_program: import_web38.SystemProgram.programId
    };
    const ix = buildMintDecisionTokensIx(accounts, {
      amount,
      buy_yes_token: buyYesToken,
      minimum_out: minimumOut
    }, this.client.programId);
    const ixs = [...preIxs, ix];
    const res = await buildAndSendV0(this.client, this.signer, ixs, { computeUnitLimit: 6e5 });
    return { signature: res.signature };
  }
  async burnDecisionTokensDerived(params) {
    const { market, amount, burnYesToken } = params;
    const buyer = this.signer.publicKey;
    const mai = await this.client.connection.getAccountInfo(market, this.client.commitment);
    if (!mai) throw new Error("market account not found");
    const m = decodeAccount("Market", mai.data);
    const yesTokenMint = new import_web38.PublicKey(m.yesTokenMint ?? m.yes_token_mint);
    const noTokenMint = new import_web38.PublicKey(m.noTokenMint ?? m.no_token_mint);
    const collateralMint = new import_web38.PublicKey(m.collateralToken ?? m.collateral_token);
    const marketCreator = new import_web38.PublicKey(m.creator ?? m.market_creator ?? m.creator);
    const creatorFeeTreasury = new import_web38.PublicKey(m.creatorFeeTreasury ?? m.creator_fee_treasury);
    const [globalConfig] = deriveGlobalConfigPda(this.client.programId);
    const gai = await this.client.connection.getAccountInfo(globalConfig, this.client.commitment);
    if (!gai) throw new Error("global_config not initialized");
    const g = decodeAccount("GlobalConfig", gai.data);
    const admin = new import_web38.PublicKey(g.admin);
    const [yesAi, noAi, colAi] = await Promise.all([
      this.client.connection.getAccountInfo(yesTokenMint, this.client.commitment),
      this.client.connection.getAccountInfo(noTokenMint, this.client.commitment),
      this.client.connection.getAccountInfo(collateralMint, this.client.commitment)
    ]);
    if (!yesAi || !noAi || !colAi) throw new Error("one or more mint accounts not found");
    const tokenProgramId = yesAi.owner.equals(import_spl_token3.TOKEN_2022_PROGRAM_ID) ? import_spl_token3.TOKEN_2022_PROGRAM_ID : import_spl_token3.TOKEN_PROGRAM_ID;
    const ataProgramId = import_spl_token3.ASSOCIATED_TOKEN_PROGRAM_ID;
    if (!(yesAi.owner.equals(noAi.owner) && yesAi.owner.equals(colAi.owner))) {
      const owners = [yesAi.owner.toBase58(), noAi.owner.toBase58(), colAi.owner.toBase58()];
      throw new Error(`Market mint program mismatch. Owners: YES=${owners[0]}, NO=${owners[1]}, COLLATERAL=${owners[2]}. All mints must share the same token program.`);
    }
    const buyerYesTokenAccount = deriveAta(buyer, yesTokenMint, false, tokenProgramId, ataProgramId);
    const buyerNoTokenAccount = deriveAta(buyer, noTokenMint, false, tokenProgramId, ataProgramId);
    const buyerCollateralTokenAccount = deriveAta(buyer, collateralMint, false, tokenProgramId, ataProgramId);
    const adminCollateralTokenAccount = deriveAta(admin, collateralMint, false, tokenProgramId, ataProgramId);
    const marketReserveVault = deriveAta(market, collateralMint, true, tokenProgramId, ataProgramId);
    const accounts = {
      buyer,
      admin,
      market_creator: marketCreator,
      market,
      global_config: globalConfig,
      yes_token_mint: yesTokenMint,
      no_token_mint: noTokenMint,
      buyer_yes_token_account: buyerYesTokenAccount,
      buyer_no_token_account: buyerNoTokenAccount,
      market_reserve_vault: marketReserveVault,
      collateral_token_mint: collateralMint,
      buyer_collateral_token_account: buyerCollateralTokenAccount,
      admin_collateral_token_account: adminCollateralTokenAccount,
      creator_fee_treasury: creatorFeeTreasury,
      token_program: tokenProgramId,
      associated_token_program: ataProgramId,
      system_program: import_web38.SystemProgram.programId
    };
    const ix = buildBurnDecisionTokensIx(accounts, {
      amount,
      burn_yes_token: burnYesToken
    }, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], { computeUnitLimit: 6e5 });
    return { signature: res.signature };
  }
  // ===== High-level helpers mirrored from working Node script =====
  async getMarketInfo(market) {
    const mai = await this.client.connection.getAccountInfo(market, this.client.commitment);
    if (!mai) throw new Error("market account not found");
    const m = this.decodeMarketAny(mai.data);
    return {
      address: market,
      question: m.question,
      id: m.id ?? m.market_id,
      creator: new import_web38.PublicKey(m.creator ?? m.market_creator ?? m.creator),
      initialLiquidity: m.initialLiquidity ?? m.initial_liquidity,
      marketReserves: m.marketReserves ?? m.market_reserves,
      endTime: m.endTime ?? m.end_time,
      resolvable: m.resolvable,
      resolved: m.resolved,
      winningTokenId: m.winningTokenId ?? m.winning_token_id,
      yesTokenMint: new import_web38.PublicKey(m.yesTokenMint ?? m.yes_token_mint),
      noTokenMint: new import_web38.PublicKey(m.noTokenMint ?? m.no_token_mint),
      collateralToken: new import_web38.PublicKey(m.collateralToken ?? m.collateral_token),
      yesTokenSupplyMinted: m.yesTokenSupplyMinted ?? m.yes_token_supply_minted,
      noTokenSupplyMinted: m.noTokenSupplyMinted ?? m.no_token_supply_minted
    };
  }
  async getBalances(market) {
    const info = await this.getMarketInfo(market);
    const owner = this.signer.publicKey;
    const collateralAta = deriveAta(owner, info.collateralToken);
    const yesAta = deriveAta(owner, info.yesTokenMint);
    const noAta = deriveAta(owner, info.noTokenMint);
    const [coll, yes, no] = await Promise.all([
      this.client.connection.getTokenAccountBalance(collateralAta).catch(() => null),
      this.client.connection.getTokenAccountBalance(yesAta).catch(() => null),
      this.client.connection.getTokenAccountBalance(noAta).catch(() => null)
    ]);
    return {
      collateral: {
        account: collateralAta,
        amount: coll?.value?.amount ?? "0",
        uiAmount: coll?.value?.uiAmount ?? 0,
        uiAmountString: coll?.value?.uiAmountString ?? "0"
      },
      yes: {
        account: yesAta,
        amount: yes?.value?.amount ?? "0",
        uiAmount: yes?.value?.uiAmount ?? 0,
        uiAmountString: yes?.value?.uiAmountString ?? "0"
      },
      no: {
        account: noAta,
        amount: no?.value?.amount ?? "0",
        uiAmount: no?.value?.uiAmount ?? 0,
        uiAmountString: no?.value?.uiAmountString ?? "0"
      }
    };
  }
  async getPrices(market) {
    const info = await this.getMarketInfo(market);
    const yes = Number(info.yesTokenSupplyMinted ?? 0n);
    const no = Number(info.noTokenSupplyMinted ?? 0n);
    const total = yes + no;
    const yesShare = total > 0 ? yes / total : 0.5;
    const noShare = total > 0 ? no / total : 0.5;
    return { yesMinted: yes, noMinted: no, totalMinted: total, yesShare, noShare };
  }
  async buyTokensUsdc(params) {
    const { market, buyYesToken } = params;
    if (!Number.isFinite(params.amountUsdc) || params.amountUsdc <= 0) throw new Error("Invalid amountUsdc");
    const info = await this.getMarketInfo(market);
    try {
      const nowSec = Math.floor(Date.now() / 1e3);
      const rawEnd = info.endTime;
      let endSec = null;
      if (typeof rawEnd === "bigint") {
        endSec = Number(rawEnd);
      } else if (typeof rawEnd === "number") {
        endSec = rawEnd;
      } else if (typeof rawEnd === "string") {
        const hexMatch = /^[0-9a-fA-F]+$/.test(rawEnd);
        try {
          const bi = hexMatch ? BigInt("0x" + rawEnd) : BigInt(rawEnd);
          endSec = Number(bi);
        } catch {
          const n = Number(rawEnd);
          endSec = Number.isFinite(n) ? n : null;
        }
      }
      const ended = endSec !== null ? nowSec >= endSec : false;
      const resolved = info.resolved === true;
      if (resolved || ended) {
        const endIso = endSec ? new Date(endSec * 1e3).toISOString() : "unknown";
        throw new Error(`Market not tradable: ${resolved ? "resolved" : "ended"}. End time: ${endIso}.`);
      }
    } catch (e) {
      if (e instanceof Error && e.message.startsWith("Market not tradable")) {
        throw e;
      }
    }
    const collateralMint = info.collateralToken;
    const mintAi = await this.client.connection.getAccountInfo(collateralMint, this.client.commitment);
    if (!mintAi) throw new Error("collateral mint account not found");
    const is2022 = mintAi.owner.equals(import_spl_token3.TOKEN_2022_PROGRAM_ID);
    const tokenProgram = is2022 ? import_spl_token3.TOKEN_2022_PROGRAM_ID : import_spl_token3.TOKEN_PROGRAM_ID;
    const mintInfo = await (0, import_spl_token3.getMint)(this.client.connection, collateralMint, this.client.commitment, tokenProgram);
    const decimals = mintInfo.decimals ?? 6;
    const scaleBI = 10n ** BigInt(decimals);
    const amtStr = String(params.amountUsdc);
    const [intPartRaw, fracPartRaw = ""] = amtStr.split(".");
    const intBI = intPartRaw ? BigInt(intPartRaw) : 0n;
    const fracPadded = (fracPartRaw + "0".repeat(decimals)).slice(0, decimals);
    const fracBI = fracPadded.length ? BigInt(fracPadded) : 0n;
    const amount = intBI * scaleBI + fracBI;
    try {
      console.log("[buyTokensUsdc] amount_usdc=", params.amountUsdc, "decimals=", decimals, "base_units=", amount.toString());
    } catch {
    }
    const minimumOut = params.minimumOut ?? 0n;
    const before = await this.getBalances(market);
    let signature = "";
    try {
      const res = await this.mintDecisionTokensDerived({ market, amount, buyYesToken, minimumOut });
      signature = res.signature;
    } catch (e) {
      const base = `buyTokensUsdc failed (amount_usdc=${params.amountUsdc}, decimals=${decimals}, base_units=${amount.toString()}, buyYesToken=${buyYesToken})`;
      if (e instanceof import_web38.SendTransactionError) {
        const logs = await e.getLogs(this.client.connection).catch(() => void 0);
        throw new Error(`${base}. On-chain logs: ${JSON.stringify(logs ?? [])}. Cause: ${e.message}`);
      }
      throw new Error(`${base}. Cause: ${e?.message ?? String(e)}`);
    }
    await new Promise((r) => setTimeout(r, 1500));
    const after = await this.getBalances(market);
    const usdcSpent = Number(before.collateral.uiAmount) - Number(after.collateral.uiAmount);
    const tokenDelta = Number(buyYesToken ? after.yes.uiAmount : after.no.uiAmount) - Number(buyYesToken ? before.yes.uiAmount : before.no.uiAmount);
    return {
      signature,
      usdcSpent,
      tokensReceived: tokenDelta,
      before,
      after
    };
  }
  async sellTokensBase(params) {
    const { market, burnYesToken, amountBaseUnits } = params;
    if (amountBaseUnits <= 0n) throw new Error("Invalid amountBaseUnits");
    const before = await this.getBalances(market);
    let signature = "";
    try {
      const res = await this.burnDecisionTokensDerived({ market, amount: amountBaseUnits, burnYesToken });
      signature = res.signature;
    } catch (e) {
      const info = await this.getMarketInfo(market);
      const mint = burnYesToken ? info.yesTokenMint : info.noTokenMint;
      const mintInfo = await (0, import_spl_token3.getMint)(this.client.connection, mint, this.client.commitment).catch(() => void 0);
      const decimals = mintInfo?.decimals ?? 6;
      const base = `sellTokensBase failed (burnYesToken=${burnYesToken}, base_units=${amountBaseUnits.toString()}, token_decimals=${decimals})`;
      if (e instanceof import_web38.SendTransactionError) {
        const logs = await e.getLogs(this.client.connection).catch(() => void 0);
        throw new Error(`${base}. On-chain logs: ${JSON.stringify(logs ?? [])}. Cause: ${e.message}`);
      }
      throw new Error(`${base}. Cause: ${e?.message ?? String(e)}`);
    }
    await new Promise((r) => setTimeout(r, 1500));
    const after = await this.getBalances(market);
    const tokensSold = Number(burnYesToken ? before.yes.uiAmount : before.no.uiAmount) - Number(burnYesToken ? after.yes.uiAmount : after.no.uiAmount);
    const usdcReceived = Number(after.collateral.uiAmount) - Number(before.collateral.uiAmount);
    return { signature, tokensSold, usdcReceived, before, after };
  }
  async redeemPosition(market) {
    const mai = await this.client.connection.getAccountInfo(market, this.client.commitment);
    if (!mai) throw new Error("market account not found");
    const m = decodeAccount("Market", mai.data);
    const yesTokenMint = new import_web38.PublicKey(m.yesTokenMint ?? m.yes_token_mint);
    const noTokenMint = new import_web38.PublicKey(m.noTokenMint ?? m.no_token_mint);
    const collateralMint = new import_web38.PublicKey(m.collateralToken ?? m.collateral_token);
    const marketCreator = new import_web38.PublicKey(m.creator ?? m.market_creator ?? m.creator);
    const creatorFeeTreasury = new import_web38.PublicKey(m.creatorFeeTreasury ?? m.creator_fee_treasury);
    const [globalConfig] = deriveGlobalConfigPda(this.client.programId);
    const gai = await this.client.connection.getAccountInfo(globalConfig, this.client.commitment);
    if (!gai) throw new Error("global_config not initialized");
    const g = decodeAccount("GlobalConfig", gai.data);
    const admin = new import_web38.PublicKey(g.admin);
    const buyer = this.signer.publicKey;
    const buyerYesTokenAccount = deriveAta(buyer, yesTokenMint);
    const buyerNoTokenAccount = deriveAta(buyer, noTokenMint);
    const buyerCollateralTokenAccount = deriveAta(buyer, collateralMint);
    const adminCollateralTokenAccount = deriveAta(admin, collateralMint);
    const marketReserveVault = deriveAta(market, collateralMint, true);
    const accounts = {
      buyer,
      admin,
      market_creator: marketCreator,
      market,
      global_config: globalConfig,
      yes_token_mint: yesTokenMint,
      no_token_mint: noTokenMint,
      buyer_yes_token_account: buyerYesTokenAccount,
      buyer_no_token_account: buyerNoTokenAccount,
      market_reserve_vault: marketReserveVault,
      collateral_token_mint: collateralMint,
      buyer_collateral_token_account: buyerCollateralTokenAccount,
      admin_collateral_token_account: adminCollateralTokenAccount,
      creator_fee_treasury: creatorFeeTreasury,
      token_program: import_spl_token3.TOKEN_PROGRAM_ID,
      associated_token_program: import_spl_token3.ASSOCIATED_TOKEN_PROGRAM_ID,
      system_program: import_web38.SystemProgram.programId
    };
    throw new Error("redeemPosition not implemented in SDK yet");
  }
};

// src/modules/redemption.ts
var import_web310 = require("@solana/web3.js");
var import_zod3 = require("zod");

// src/instructions/redemption.ts
var import_web39 = require("@solana/web3.js");
function buildRedeemIx(params) {
  const { holder, market, position } = params;
  const disc = 2;
  const data = Buffer.from([disc]);
  const keys = [
    { pubkey: holder, isSigner: true, isWritable: true },
    { pubkey: market, isSigner: false, isWritable: true },
    { pubkey: position, isSigner: false, isWritable: true }
  ];
  return new import_web39.TransactionInstruction({ keys, programId: PNP_PROGRAM_ID, data });
}

// src/modules/redemption.ts
var RedeemSchema = import_zod3.z.object({
  market: import_zod3.z.instanceof(import_web310.PublicKey),
  position: import_zod3.z.instanceof(import_web310.PublicKey),
  amount: import_zod3.z.bigint(),
  to: import_zod3.z.instanceof(import_web310.PublicKey).optional()
});
var RedemptionModule = class {
  constructor(client, signer) {
    this.client = client;
    this.signer = signer;
  }
  async redeemPosition(params) {
    const p = RedeemSchema.parse(params);
    const ix = buildRedeemIx({
      holder: this.signer.publicKey,
      market: p.market,
      position: p.position,
      amount: p.amount
    });
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  // IDL-backed creator fee claim
  async claimCreatorFee(accounts) {
    const ix = buildClaimCreatorFeeIx(accounts, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  // IDL-backed creator refund
  async creatorRefund(accounts) {
    const ix = buildCreatorRefundIx(accounts, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  // IDL-backed creator refund V2
  async creatorRefundV2(accounts) {
    const ix = buildCreatorRefundV2Ix(accounts, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  // IDL-backed creator refund V3
  async creatorRefundV3(accounts) {
    const ix = buildCreatorRefundV3Ix(accounts, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  /**
   * Redeem a winning position from a resolved market
   * @param accounts - Account mapping for the redemption instruction
   * @returns Transaction signature
   */
  async redeemPositionV2(accounts) {
    const ix = buildRedeemPositionV2Ix(accounts, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
  /**
   * Redeem a winning position from a resolved V3 market
   * @param accounts - Account mapping for the V3 redemption instruction
   * @returns Transaction signature
   */
  async redeemV3Position(accounts) {
    const ix = buildRedeemV3PositionIx(accounts, this.client.programId);
    const res = await buildAndSendV0(this.client, this.signer, [ix], {
      computeUnitLimit: 8e5
    });
    return { signature: res.signature };
  }
};

// src/lib/anchor-client.ts
var import_web311 = require("@solana/web3.js");
var import_bn2 = require("bn.js");
var anchor = __toESM(require("@coral-xyz/anchor"), 1);
var MAINNET_PROGRAM_ID2 = new import_web311.PublicKey("6fnYZUSyp3vJxTNnayq5S62d363EFaGARnqYux5bqrxb");
var DEVNET_PROGRAM_ID2 = new import_web311.PublicKey("pnpkv2qnh4bfpGvTugGDSEhvZC7DP4pVxTuDykV3BGz");
var AnchorClient = class _AnchorClient {
  constructor(connection, signer, idlOverride, programIdOverride) {
    this.connection = connection;
    this.signer = signer;
    this.idlOverride = idlOverride;
    this.programIdOverride = programIdOverride;
    this.wallet = new anchor.Wallet(signer);
    this.provider = new anchor.AnchorProvider(connection, this.wallet, { commitment: "confirmed" });
    anchor.setProvider(this.provider);
    try {
      const verbose = process.env.VERBOSE === "1" || process.env.PNP_DEBUG === "1";
      if (verbose) {
        console.log("Initializing Anchor program with IDL");
      }
      const baseIdl = this.idlOverride ?? PNP_IDL;
      const programId = this.programIdOverride;
      if (programId) {
        const idlWithAddress = { ...baseIdl, address: programId.toBase58() };
        this.program = new anchor.Program(idlWithAddress, this.provider);
      } else {
        this.program = new anchor.Program(baseIdl, this.provider);
      }
      if (verbose) {
        console.log("Program loaded successfully");
        console.log(`Program ID: ${this.program.programId.toString()}`);
      }
    } catch (err) {
      console.error("Failed to initialize Anchor program:", err);
      throw err;
    }
  }
  provider;
  wallet;
  program;
  /**
   * Convert a JavaScript BigInt or number to Anchor BN
   */
  static toBN(value) {
    return new import_bn2.BN(value.toString());
  }
  /**
   * Returns the IDL for the PNP program
   */
  static async getIdl() {
    return PNP_IDL;
  }
  static fromIdl(connection, signer, idl) {
    return new _AnchorClient(connection, signer, idl);
  }
  /**
   * Get the wallet's public key
   */
  get walletPublicKey() {
    return this.wallet.publicKey;
  }
};

// src/modules/anchor-market.ts
var import_web312 = require("@solana/web3.js");
var import_spl_token4 = require("@solana/spl-token");
var AnchorMarketModule = class {
  constructor(anchorClient) {
    this.anchorClient = anchorClient;
  }
  /**
   * Create a new prediction market using direct Anchor program calls
   * Following the same structure as the working JavaScript example
   */
  async createMarket(params) {
    const { question, initialLiquidity, endTime, collateralTokenMint } = params;
    const creatorOverride = params.creator ?? this.anchorClient.walletPublicKey;
    const initialLiquidityBN = AnchorClient.toBN(initialLiquidity);
    const endTimeBN = AnchorClient.toBN(endTime);
    console.log("\u{1F680} Creating market with parameters:");
    console.log("   Question:", question);
    console.log("   Initial Liquidity:", initialLiquidityBN.toString());
    console.log("   End Time:", new Date(Number(endTime) * 1e3).toISOString());
    console.log("   Collateral Token Mint:", collateralTokenMint.toString());
    console.log("   Creator (for fees/ownership):", creatorOverride.toBase58());
    const [globalConfig] = import_web312.PublicKey.findProgramAddressSync(
      [Buffer.from("global_config")],
      this.anchorClient.program.programId
    );
    console.log("Global Config:", globalConfig.toBase58());
    const globalConfigAccount = await this.anchorClient.program.account.globalConfig.fetch(globalConfig);
    const currentGlobalId = globalConfigAccount.globalId;
    console.log("Current Global ID:", currentGlobalId.toString());
    let marketExtension = null;
    if (params.yesOddsBps !== void 0 || params.oracle !== void 0) {
      [marketExtension] = import_web312.PublicKey.findProgramAddressSync(
        [Buffer.from("market_ext"), currentGlobalId.toArrayLike(Buffer, "le", 8)],
        this.anchorClient.program.programId
      );
      console.log("Market Extension PDA:", marketExtension.toBase58());
      if (params.yesOddsBps !== void 0) {
        console.log("Custom YES Odds (BPS):", params.yesOddsBps);
      }
      if (params.oracle !== void 0) {
        console.log("Custom Oracle:", params.oracle.toBase58());
      }
    }
    const [market] = import_web312.PublicKey.findProgramAddressSync(
      [Buffer.from("market-v2"), currentGlobalId.toArrayLike(Buffer, "le", 8)],
      this.anchorClient.program.programId
    );
    console.log("Market PDA:", market.toBase58());
    const payerCollateralTokenAccount = await (0, import_spl_token4.getAssociatedTokenAddress)(
      collateralTokenMint,
      this.anchorClient.walletPublicKey
    );
    const marketReserveVault = await (0, import_spl_token4.getAssociatedTokenAddress)(
      collateralTokenMint,
      market,
      true
      // allowOwnerOffCurve
    );
    const [creatorFeeTreasury] = import_web312.PublicKey.findProgramAddressSync(
      [Buffer.from("creator_fee_treasury"), creatorOverride.toBuffer(), collateralTokenMint.toBuffer()],
      this.anchorClient.program.programId
    );
    try {
      const computeBudgetIx = import_web312.ComputeBudgetProgram.setComputeUnitLimit({
        units: 4e5
      });
      const txSignature = await this.anchorClient.program.methods.createMarketV2(
        question,
        initialLiquidityBN,
        endTimeBN,
        creatorOverride,
        params.yesOddsBps ?? null,
        // Optional: Custom YES odds (100-9900 bps)
        params.oracle ?? null
        // Optional: Custom oracle
      ).accounts({
        payer: this.anchorClient.walletPublicKey,
        creator: creatorOverride,
        market,
        marketExtension,
        // Optional account for custom odds/oracle
        globalConfig,
        collateralTokenMint,
        payerCollateralTokenAccount,
        marketReserveVault,
        creatorFeeTreasury,
        tokenProgram: import_spl_token4.TOKEN_PROGRAM_ID,
        associatedTokenProgram: import_spl_token4.ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: import_web312.SystemProgram.programId
      }).preInstructions([computeBudgetIx]).signers([this.anchorClient.signer]).rpc();
      console.log("\u2705 Market created successfully!");
      console.log("Transaction signature:", txSignature);
      try {
        const marketAccount = await this.anchorClient.program.account.market.fetch(market);
        console.log("\n\u{1F4CA} Market Details:");
        console.log("------------------------");
        console.log("Market ID:", marketAccount.id.toString());
        console.log("Question:", marketAccount.question);
        console.log("Creator:", marketAccount.creator.toBase58());
        console.log("Initial Liquidity:", marketAccount.initialLiquidity.toString());
        console.log("Market Reserves:", marketAccount.marketReserves.toString());
        console.log("End Time:", new Date(marketAccount.endTime.toNumber() * 1e3).toISOString());
        console.log("Resolved:", marketAccount.resolved);
        console.log("------------------------");
        return {
          signature: txSignature,
          market,
          marketDetails: marketAccount
        };
      } catch (err) {
        return {
          signature: txSignature,
          market
        };
      }
    } catch (error) {
      console.error("\u{1F4A5} Error creating market:", error);
      if (error.logs) {
        console.error("Program logs:");
        error.logs.forEach((log) => console.error("  ", log));
      }
      throw error;
    }
  }
};

// src/modules/anchor-market-v3.ts
var import_web313 = require("@solana/web3.js");
var import_spl_token5 = require("@solana/spl-token");
var DEFAULT_MAX_POT_RATIO = 1e9;
var AnchorMarketV3Module = class {
  constructor(anchorClient) {
    this.anchorClient = anchorClient;
  }
  /**
   * Create a new V3 prediction market using direct Anchor program calls
   */
  async createMarketV3(params) {
    const {
      question,
      initialAmount,
      side,
      creatorSideCap,
      endTime,
      collateralTokenMint
    } = params;
    const creatorOverride = params.creator ?? this.anchorClient.walletPublicKey;
    const initialAmountBN = AnchorClient.toBN(initialAmount);
    const creatorSideCapBN = AnchorClient.toBN(creatorSideCap);
    const endTimeBN = AnchorClient.toBN(endTime);
    const sideEnum = side === "yes" ? { yes: {} } : { no: {} };
    const finalMaxPotRatio = params.maxPotRatio ?? DEFAULT_MAX_POT_RATIO;
    console.log("\u{1F680} Creating V3 market with parameters:");
    console.log("   Question:", question);
    console.log("   Initial Amount:", initialAmountBN.toString());
    console.log("   Side:", side.toUpperCase());
    console.log("   Creator Side Cap:", creatorSideCapBN.toString());
    console.log("   Max Pot Ratio:", finalMaxPotRatio);
    console.log("   End Time:", new Date(Number(endTime) * 1e3).toISOString());
    console.log("   Collateral Token Mint:", collateralTokenMint.toString());
    console.log("   Creator (for fees/ownership):", creatorOverride.toBase58());
    if (params.oddsBps !== void 0) {
      console.log("   Custom Odds (BPS):", params.oddsBps);
    }
    if (params.oracle !== void 0) {
      console.log("   Custom Oracle:", params.oracle.toBase58());
    }
    const [globalConfig] = import_web313.PublicKey.findProgramAddressSync(
      [Buffer.from("global_config")],
      this.anchorClient.program.programId
    );
    const globalConfigAccount = await this.anchorClient.program.account.globalConfig.fetch(globalConfig);
    const currentGlobalId = globalConfigAccount.globalId;
    console.log("Current Global ID:", currentGlobalId.toString());
    let marketExtension = null;
    if (params.oddsBps !== void 0 || params.oracle !== void 0) {
      [marketExtension] = import_web313.PublicKey.findProgramAddressSync(
        [Buffer.from("market_v3_ext"), currentGlobalId.toArrayLike(Buffer, "le", 8)],
        this.anchorClient.program.programId
      );
      console.log("Market Extension PDA:", marketExtension.toBase58());
    }
    const [market] = import_web313.PublicKey.findProgramAddressSync(
      [Buffer.from("market-v3"), currentGlobalId.toArrayLike(Buffer, "le", 8)],
      this.anchorClient.program.programId
    );
    console.log("Market PDA:", market.toBase58());
    const [yesTokenMint] = import_web313.PublicKey.findProgramAddressSync(
      [Buffer.from("v3-yes-token"), currentGlobalId.toArrayLike(Buffer, "le", 8)],
      this.anchorClient.program.programId
    );
    const [noTokenMint] = import_web313.PublicKey.findProgramAddressSync(
      [Buffer.from("v3-no-token"), currentGlobalId.toArrayLike(Buffer, "le", 8)],
      this.anchorClient.program.programId
    );
    const payerCollateralTokenAccount = await (0, import_spl_token5.getAssociatedTokenAddress)(
      collateralTokenMint,
      this.anchorClient.walletPublicKey
    );
    const marketReserveVault = await (0, import_spl_token5.getAssociatedTokenAddress)(
      collateralTokenMint,
      market,
      true
      // allowOwnerOffCurve
    );
    const creatorYesTokenAccount = await (0, import_spl_token5.getAssociatedTokenAddress)(
      yesTokenMint,
      creatorOverride
    );
    const creatorNoTokenAccount = await (0, import_spl_token5.getAssociatedTokenAddress)(
      noTokenMint,
      creatorOverride
    );
    const [creatorFeeTreasury] = import_web313.PublicKey.findProgramAddressSync(
      [Buffer.from("creator_fee_treasury"), creatorOverride.toBuffer(), collateralTokenMint.toBuffer()],
      this.anchorClient.program.programId
    );
    try {
      const computeBudgetIx = import_web313.ComputeBudgetProgram.setComputeUnitLimit({
        units: 4e5
      });
      const txSignature = await this.anchorClient.program.methods.createMarketV3(
        question,
        initialAmountBN,
        sideEnum,
        creatorSideCapBN,
        endTimeBN,
        finalMaxPotRatio,
        creatorOverride,
        params.oddsBps ?? null,
        // Optional: Custom odds (100-9900 bps)
        params.oracle ?? null
        // Optional: Custom oracle
      ).accounts({
        payer: this.anchorClient.walletPublicKey,
        creator: creatorOverride,
        market,
        marketExtension,
        // Optional account for custom odds/oracle
        globalConfig,
        collateralTokenMint,
        yesTokenMint,
        noTokenMint,
        payerCollateralTokenAccount,
        marketReserveVault,
        creatorYesTokenAccount,
        creatorNoTokenAccount,
        creatorFeeTreasury,
        tokenProgram: import_spl_token5.TOKEN_PROGRAM_ID,
        associatedTokenProgram: import_spl_token5.ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: import_web313.SystemProgram.programId
      }).preInstructions([computeBudgetIx]).signers([this.anchorClient.signer]).rpc();
      console.log("\u2705 V3 market created successfully!");
      console.log("Transaction signature:", txSignature);
      return {
        signature: txSignature,
        market,
        yesTokenMint,
        noTokenMint
      };
    } catch (error) {
      console.error("\u{1F4A5} Error creating V3 market:", error);
      if (error.logs) {
        console.error("Program logs:");
        error.logs.forEach((log) => console.error("  ", log));
      }
      throw error;
    }
  }
};

// src/sdk.ts
var import_spl_token6 = require("@solana/spl-token");
var import_bn3 = require("bn.js");
var PNPClient = class _PNPClient {
  client;
  signer;
  market;
  trading;
  redemption;
  anchorMarket;
  anchorMarketV3;
  anchorClient;
  // Static property for V3 market account discriminator
  static MARKET_V3_DISCRIMINATOR = (() => {
    const hex = process.env.MARKET_V3_DISCRIMINATOR || "488657404fa709bd";
    try {
      return Buffer.from(hex, "hex");
    } catch {
      return Buffer.from("488657404fa709bd", "hex");
    }
  })();
  get connection() {
    return this.client.connection;
  }
  /**
   * Decode market account data from buffer
   * @param data Buffer containing account data
   * @returns Decoded market account data
   */
  decodeMarketAny(data) {
    const prefix = data.subarray(0, 8);
    if (prefix.equals(_PNPClient.MARKET_V3_DISCRIMINATOR)) {
      return decodeAccount("MarketV3", data);
    }
    try {
      return decodeAccount("Market", data);
    } catch {
      return decodeAccount("MarketV3", data);
    }
  }
  constructor(rpcUrl, privateKey) {
    const cfg = { rpcUrl };
    this.client = new Client(cfg);
    if (privateKey) {
      let secretKey;
      if (typeof privateKey === "string") {
        try {
          secretKey = Uint8Array.from(import_bs58.default.decode(privateKey));
        } catch {
          throw new Error(
            "Invalid private key string; expected base58-encoded secret key"
          );
        }
      } else if (privateKey instanceof Uint8Array) {
        secretKey = privateKey;
      } else if (privateKey && privateKey.secretKey instanceof Uint8Array) {
        secretKey = privateKey.secretKey;
      }
      if (!secretKey) throw new Error("Unsupported privateKey format");
      const keypair = import_web314.Keypair.fromSecretKey(secretKey);
      this.signer = new NodeKeypairSigner(keypair);
      this.market = new MarketModule(this.client, this.signer);
      this.trading = new TradingModule(this.client, this.signer);
      this.redemption = new RedemptionModule(this.client, this.signer);
      try {
        this.anchorClient = new AnchorClient(
          this.client.connection,
          keypair,
          void 0,
          // idlOverride
          this.client.programId
          // Use the network-detected program ID
        );
        this.anchorMarket = new AnchorMarketModule(this.anchorClient);
        this.anchorMarketV3 = new AnchorMarketV3Module(this.anchorClient);
      } catch (err) {
        console.warn("Could not initialize Anchor client:", err);
      }
    }
  }
  /**
   * Create a P2P market (high-level wrapper) and return a web3-agnostic result.
   * Serializes PublicKeys to base58 strings to match P2PMarketResponse.
   */
  async createP2PMarketGeneral(params) {
    if (!this.anchorMarketV3) {
      throw new Error(
        "AnchorMarketV3Module not available. Initialize client with a signer."
      );
    }
    const res = await this.anchorMarketV3.createMarketV3(params);
    return {
      signature: res.signature,
      market: res.market.toBase58(),
      yesTokenMint: res.yesTokenMint.toBase58(),
      noTokenMint: res.noTokenMint.toBase58()
    };
  }
  /**
   * Create a P2P market using simple, UI-friendly parameters.
   * - Accepts amount in USDC (number) and converts to raw units internally (assumes 6 decimals).
   * - Defaults to mainnet USDC as collateral mint if not provided.
   * - Defaults creatorSideCap to 5x the initial amount if not provided.
   * - Defaults end time to `daysUntilEnd` days from now (30 days by default).
   */
  async createP2PMarketSimple(params) {
    const {
      question,
      side,
      amountUsdc,
      daysUntilEnd = 30,
      creatorSideCapMultiplier = 5,
      collateralTokenMint,
      maxPotRatio,
      creator
    } = params;
    if (!Number.isFinite(amountUsdc) || amountUsdc <= 0) {
      throw new Error("amountUsdc must be a positive number");
    }
    if (!["yes", "no"].includes(side)) {
      throw new Error("side must be 'yes' or 'no'");
    }
    const defaultUsdcMint = new import_web314.PublicKey(
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    );
    const collateralMintPk = collateralTokenMint ?? defaultUsdcMint;
    const initialAmount = this.uiToRaw(amountUsdc, 6);
    const creatorCapUsdc = amountUsdc * creatorSideCapMultiplier;
    const creatorSideCap = this.uiToRaw(creatorCapUsdc, 6);
    const nowSeconds = Math.floor(Date.now() / 1e3);
    const endTimeSeconds = nowSeconds + daysUntilEnd * 24 * 60 * 60;
    const endTime = BigInt(endTimeSeconds);
    return this.createP2PMarketGeneral({
      question,
      initialAmount,
      side,
      creatorSideCap,
      endTime,
      maxPotRatio,
      collateralTokenMint: collateralMintPk,
      creator
    });
  }
  /**
   * Create a P2P market with YouTube URL detection (high-level wrapper).
   * Automatically detects and extracts YouTube URLs from the question.
   * Serializes PublicKeys to base58 strings to match P2PMarketResponse.
   */
  async createP2PMarketYoutube(params) {
    const { question, youtubeUrl, ...rest } = params;
    const questionWithUrl = youtubeUrl && youtubeUrl.length > 0 ? `${question}${question.endsWith(" ") ? "" : " "}${youtubeUrl}` : question;
    const detected = _PNPClient.detectYoutubeUrl(questionWithUrl);
    const result = await this.createP2PMarketGeneral({
      ...rest,
      question: questionWithUrl
    });
    return {
      ...result,
      detectedYoutubeUrl: youtubeUrl || detected.youtubeUrl
    };
  }
  /**
   * Create a P2P market with DeFiLlama protocol/metric detection (high-level wrapper).
   * Automatically formats the question with DeFiLlama reference.
   * Serializes PublicKeys to base58 strings to match P2PMarketResponse.
   */
  async createP2PMarketDefiLlama(params) {
    const { question, protocolName, metric, ...rest } = params;
    const finalQuestion = `${question}${question.endsWith(" ") ? "" : " "}df ${protocolName} ${metric}`;
    const result = await this.createP2PMarketGeneral({
      ...rest,
      question: finalQuestion
    });
    return {
      ...result,
      detectedProtocol: protocolName,
      detectedMetric: metric
    };
  }
  /**
   * Simple helper to create a P2P market with a YouTube URL using UI-friendly parameters.
   * - Accepts amount in USDC (number) and converts to raw units internally (assumes 6 decimals).
   * - Defaults to mainnet USDC as collateral mint if not provided.
   * - Defaults creatorSideCap to 5x the initial amount if not provided.
   * - Defaults end time to `daysUntilEnd` days from now (30 days by default).
   */
  async createP2PMarketYoutubeSimple(params) {
    const {
      question,
      youtubeUrl,
      side,
      amountUsdc,
      daysUntilEnd = 30,
      creatorSideCapMultiplier = 5,
      collateralTokenMint,
      maxPotRatio,
      creator
    } = params;
    if (!Number.isFinite(amountUsdc) || amountUsdc <= 0) {
      throw new Error("amountUsdc must be a positive number");
    }
    if (!["yes", "no"].includes(side)) {
      throw new Error("side must be 'yes' or 'no'");
    }
    const defaultUsdcMint = new import_web314.PublicKey(
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    );
    const collateralMintPk = collateralTokenMint ?? defaultUsdcMint;
    const initialAmount = this.uiToRaw(amountUsdc, 6);
    const creatorCapUsdc = amountUsdc * creatorSideCapMultiplier;
    const creatorSideCap = this.uiToRaw(creatorCapUsdc, 6);
    const nowSeconds = Math.floor(Date.now() / 1e3);
    const endTimeSeconds = nowSeconds + daysUntilEnd * 24 * 60 * 60;
    const endTime = BigInt(endTimeSeconds);
    return this.createP2PMarketYoutube({
      question,
      youtubeUrl,
      initialAmount,
      side,
      creatorSideCap,
      endTime,
      maxPotRatio,
      collateralTokenMint: collateralMintPk,
      creator
    });
  }
  /**
   * Create a V2 (AMM) market with Twitter URL detection (high-level wrapper).
   * Automatically detects and extracts Twitter URLs from the question.
   * Serializes PublicKeys to base58 strings.
   */
  async createMarketTwitter(params) {
    const { question, tweetUrl, initialLiquidity, endTime, collateralTokenMint } = params;
    if (!this.market) {
      throw new Error("MarketModule not available. Initialize client with a signer.");
    }
    const patterns = [
      /https?:\/\/(?:www\.)?twitter\.com\/[^/]+\/status\/(\d+)/i,
      /https?:\/\/(?:www\.)?x\.com\/[^/]+\/status\/(\d+)/i,
      /https?:\/\/(?:mobile\.)?twitter\.com\/[^/]+\/status\/(\d+)/i
    ];
    let tweetId = null;
    for (const re of patterns) {
      const m = tweetUrl.match(re);
      if (m && m[1]) {
        tweetId = m[1];
        break;
      }
    }
    if (!tweetId) {
      const m = tweetUrl.match(/(\d{8,})/);
      if (m && m[1]) tweetId = m[1];
    }
    if (!tweetId) {
      throw new Error("Unable to extract tweet ID from tweetUrl");
    }
    const finalQuestion = `${question}${question.endsWith(" ") ? "" : " "}X {${tweetId}}`;
    const result = await this.market.createMarket({
      question: finalQuestion,
      initialLiquidity,
      endTime,
      baseMint: collateralTokenMint
    });
    if (!result.signature) {
      throw new Error("Transaction failed: No signature returned");
    }
    return {
      signature: result.signature,
      market: result.market.toBase58(),
      detectedTwitterUrl: tweetUrl,
      isTweetIdFormat: true
    };
  }
  /**
   * Create a V2 (AMM) market with YouTube URL detection (high-level wrapper).
   * Automatically detects and extracts YouTube URLs from the question.
   * Serializes PublicKeys to base58 strings.
   */
  async createMarketYoutube(params) {
    const { question, youtubeUrl, initialLiquidity, endTime, collateralTokenMint } = params;
    if (!this.market) {
      throw new Error("MarketModule not available. Initialize client with a signer.");
    }
    const questionWithUrl = youtubeUrl && youtubeUrl.length > 0 ? `${question}${question.endsWith(" ") ? "" : " "}${youtubeUrl}` : question;
    const detected = _PNPClient.detectYoutubeUrl(questionWithUrl);
    const result = await this.market.createMarket({
      question: questionWithUrl,
      initialLiquidity,
      endTime,
      baseMint: collateralTokenMint
    });
    if (!result.signature) {
      throw new Error("Transaction failed: No signature returned");
    }
    return {
      signature: result.signature,
      market: result.market.toBase58(),
      detectedYoutubeUrl: youtubeUrl || detected.youtubeUrl
    };
  }
  /**
   * Create a V2 (AMM) market with DeFiLlama protocol/metric detection (high-level wrapper).
   * Automatically formats the question with DeFiLlama reference.
   * Serializes PublicKeys to base58 strings.
   */
  async createMarketDefiLlama(params) {
    const { question, protocolName, metric, initialLiquidity, endTime, collateralTokenMint } = params;
    if (!this.market) {
      throw new Error("MarketModule not available. Initialize client with a signer.");
    }
    const finalQuestion = `${question}${question.endsWith(" ") ? "" : " "}df ${protocolName} ${metric}`;
    const result = await this.market.createMarket({
      question: finalQuestion,
      initialLiquidity,
      endTime,
      baseMint: collateralTokenMint
    });
    if (!result.signature) {
      throw new Error("Transaction failed: No signature returned");
    }
    return {
      signature: result.signature,
      market: result.market.toBase58(),
      detectedProtocol: protocolName,
      detectedMetric: metric
    };
  }
  /**
   * Create a P2P market with Twitter URL detection (high-level wrapper).
   * Automatically detects and extracts Twitter URLs from the question.
   * Serializes PublicKeys to base58 strings to match P2PMarketResponse.
   */
  async createP2PMarketTwitter(params) {
    const { question, tweetUrl, ...rest } = params;
    const patterns = [
      /https?:\/\/(?:www\.)?twitter\.com\/[^/]+\/status\/(\d+)/i,
      /https?:\/\/(?:www\.)?x\.com\/[^/]+\/status\/(\d+)/i,
      /https?:\/\/(?:mobile\.)?twitter\.com\/[^/]+\/status\/(\d+)/i
    ];
    let tweetId = null;
    for (const re of patterns) {
      const m = tweetUrl.match(re);
      if (m && m[1]) {
        tweetId = m[1];
        break;
      }
    }
    if (!tweetId) {
      const m = tweetUrl.match(/(\d{8,})/);
      if (m && m[1]) tweetId = m[1];
    }
    if (!tweetId) {
      throw new Error("Unable to extract tweet ID from tweetUrl");
    }
    const finalQuestion = `${question}${question.endsWith(" ") ? "" : " "}X {${tweetId}}`;
    const result = await this.createP2PMarketGeneral({
      ...rest,
      question: finalQuestion
    });
    return {
      ...result,
      detectedTwitterUrl: tweetUrl,
      isTweetIdFormat: true
    };
  }
  /**
   * Simple helper to create a P2P market with a Twitter / X URL using UI-friendly parameters.
   * - Accepts amount in USDC (number) and converts to raw units internally (assumes 6 decimals).
   * - Defaults to mainnet USDC as collateral mint if not provided.
   * - Defaults creatorSideCap to 5x the initial amount if not provided.
   * - Defaults end time to `daysUntilEnd` days from now (30 days by default).
   */
  async createP2PMarketTwitterSimple(params) {
    const {
      question,
      tweetUrl,
      side,
      amountUsdc,
      daysUntilEnd = 30,
      creatorSideCapMultiplier = 5,
      collateralTokenMint,
      maxPotRatio,
      creator
    } = params;
    if (!Number.isFinite(amountUsdc) || amountUsdc <= 0) {
      throw new Error("amountUsdc must be a positive number");
    }
    if (!["yes", "no"].includes(side)) {
      throw new Error("side must be 'yes' or 'no'");
    }
    const defaultUsdcMint = new import_web314.PublicKey(
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    );
    const collateralMintPk = collateralTokenMint ?? defaultUsdcMint;
    const initialAmount = this.uiToRaw(amountUsdc, 6);
    const creatorCapUsdc = amountUsdc * creatorSideCapMultiplier;
    const creatorSideCap = this.uiToRaw(creatorCapUsdc, 6);
    const nowSeconds = Math.floor(Date.now() / 1e3);
    const endTimeSeconds = nowSeconds + daysUntilEnd * 24 * 60 * 60;
    const endTime = BigInt(endTimeSeconds);
    return this.createP2PMarketTwitter({
      question,
      tweetUrl,
      initialAmount,
      side,
      creatorSideCap,
      endTime,
      maxPotRatio,
      collateralTokenMint: collateralMintPk,
      creator
    });
  }
  /**
   * Simple helper to create a P2P market with DeFiLlama protocol/metric using UI-friendly parameters.
   * - Accepts amount in USDC (number) and converts to raw units internally (assumes 6 decimals).
   * - Defaults to mainnet USDC as collateral mint if not provided.
   * - Defaults creatorSideCap to 5x the initial amount if not provided.
   * - Defaults end time to `daysUntilEnd` days from now (30 days by default).
   */
  async createP2PMarketDefiLlamaSimple(params) {
    const {
      question,
      protocolName,
      metric,
      side,
      amountUsdc,
      daysUntilEnd = 30,
      creatorSideCapMultiplier = 5,
      collateralTokenMint,
      maxPotRatio,
      creator
    } = params;
    if (!Number.isFinite(amountUsdc) || amountUsdc <= 0) {
      throw new Error("amountUsdc must be a positive number");
    }
    if (!["yes", "no"].includes(side)) {
      throw new Error("side must be 'yes' or 'no'");
    }
    const defaultUsdcMint = new import_web314.PublicKey(
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    );
    const collateralMintPk = collateralTokenMint ?? defaultUsdcMint;
    const initialAmount = this.uiToRaw(amountUsdc, 6);
    const creatorCapUsdc = amountUsdc * creatorSideCapMultiplier;
    const creatorSideCap = this.uiToRaw(creatorCapUsdc, 6);
    const nowSeconds = Math.floor(Date.now() / 1e3);
    const endTimeSeconds = nowSeconds + daysUntilEnd * 24 * 60 * 60;
    const endTime = BigInt(endTimeSeconds);
    return this.createP2PMarketDefiLlama({
      question,
      protocolName,
      metric,
      initialAmount,
      side,
      creatorSideCap,
      endTime,
      maxPotRatio,
      collateralTokenMint: collateralMintPk,
      creator
    });
  }
  /**
   * Create a V2 (AMM) market with custom initial odds and/or a custom oracle.
   * 
   * @param params - Market creation parameters
   * @param params.yesOddsBps - Initial YES odds in basis points (100-9900). 
   *   Example: 7000 = 70% YES / 30% NO
   * @param params.oracle - Optional custom oracle for settlement (default: global oracle)
   * @returns Object with transaction signature and market PDA
   */
  async createMarketV2WithCustomOdds(params) {
    if (!this.anchorMarket) {
      throw new Error("AnchorMarketModule not available. Initialize client with a signer.");
    }
    if (params.yesOddsBps < 100 || params.yesOddsBps > 9900) {
      throw new Error("yesOddsBps must be between 100 and 9900 (1% to 99%)");
    }
    const res = await this.anchorMarket.createMarket({
      question: params.question,
      initialLiquidity: params.initialLiquidity,
      endTime: params.endTime,
      collateralTokenMint: params.collateralTokenMint,
      yesOddsBps: params.yesOddsBps,
      oracle: params.oracle,
      creator: params.creator
    });
    return {
      signature: res.signature,
      market: res.market.toBase58()
    };
  }
  /**
   * Create a P2P (V3) market with custom initial odds (high-level wrapper).
   * Custom odds allow splitting the initial liquidity between YES and NO sides
   * instead of the default 100% to creator side.
   * 
   * @param params - Market creation parameters
   * @param params.oddsBps - Initial odds in basis points (100-9900). 
   *   Example: 7000 = 70% YES / 30% NO for a YES-side creator
   * @param params.oracle - Optional custom oracle for settlement (default: global oracle)
   * @returns P2PMarketResponse with market address and token mints
   */
  async createMarketP2PWithCustomOdds(params) {
    if (!this.anchorMarketV3) {
      throw new Error(
        "AnchorMarketV3Module not available. Initialize client with a signer."
      );
    }
    if (params.oddsBps < 100 || params.oddsBps > 9900) {
      throw new Error("oddsBps must be between 100 and 9900 (1% to 99%)");
    }
    const res = await this.anchorMarketV3.createMarketV3({
      question: params.question,
      initialAmount: params.initialAmount,
      side: params.side,
      creatorSideCap: params.creatorSideCap,
      endTime: params.endTime,
      maxPotRatio: params.maxPotRatio,
      collateralTokenMint: params.collateralTokenMint,
      creator: params.creator,
      oddsBps: params.oddsBps,
      oracle: params.oracle
    });
    return {
      signature: res.signature,
      market: res.market.toBase58(),
      yesTokenMint: res.yesTokenMint.toBase58(),
      noTokenMint: res.noTokenMint.toBase58()
    };
  }
  /**
   * Detects if a question contains a Twitter URL or tweet ID format after the question mark
   * @param questionText The question text to analyze
   * @returns Object containing the cleaned question, Twitter URL if present, and isTweetIdFormat flag indicating if X {tweet_id} format was used
   * @example 
   * // With URL format
   * detectTwitterUrl("Will X happen? https://twitter.com/user/status/1234567890");
   * // With X {tweet id} format - with space
   * detectTwitterUrl("Will X happen? X 1234567890");
   * // With X {tweet id} format - with curly braces
   * detectTwitterUrl("Will X happen? X {1234567890}");
   */
  static detectTwitterUrl(questionText) {
    const questionMarkIndex = questionText.indexOf("?");
    if (questionMarkIndex === -1) {
      return { question: questionText };
    }
    const afterQuestionMark = questionText.substring(questionMarkIndex + 1).trim();
    if (!afterQuestionMark) {
      return { question: questionText };
    }
    const twitterUrlPatterns = [
      /https?:\/\/(?:www\.)?twitter\.com\//i,
      /https?:\/\/(?:www\.)?x\.com\//i,
      /https?:\/\/(?:www\.)?t\.co\//i
    ];
    const hasTwitterUrl = twitterUrlPatterns.some((pattern) => pattern.test(afterQuestionMark));
    if (hasTwitterUrl) {
      return {
        question: questionText.substring(0, questionMarkIndex + 1).trim(),
        twitterUrl: afterQuestionMark,
        isTweetIdFormat: false
      };
    }
    const xTweetIdMatch = afterQuestionMark.match(/^\s*X\s+(\d+)\s*$/i) || afterQuestionMark.match(/^\s*X\s*\{(\d+)\}\s*$/i);
    if (xTweetIdMatch) {
      const tweetId = xTweetIdMatch[1];
      const twitterUrl = `https://twitter.com/x/status/${tweetId}`;
      return {
        question: questionText.substring(0, questionMarkIndex + 1).trim(),
        twitterUrl,
        isTweetIdFormat: true
      };
    }
    return { question: questionText };
  }
  /**
   * Detects if a question contains a YouTube URL after the question mark
   * @param questionText The question text to analyze
   * @returns Object containing the cleaned question and YouTube URL if present
   */
  static detectYoutubeUrl(questionText) {
    const questionMarkIndex = questionText.indexOf("?");
    if (questionMarkIndex === -1) {
      return { question: questionText };
    }
    const afterQuestionMark = questionText.substring(questionMarkIndex + 1).trim();
    if (!afterQuestionMark) {
      return { question: questionText };
    }
    const youtubeUrlPatterns = [
      /https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[\w-]+/i,
      // Standard YouTube URL
      /https?:\/\/(?:www\.)?youtube\.com\/v\/[\w-]+/i,
      // Embedded YouTube URL
      /https?:\/\/(?:www\.)?youtube\.com\/embed\/[\w-]+/i,
      // iFrame YouTube URL
      /https?:\/\/(?:www\.)?youtu\.be\/[\w-]+/i,
      // Short YouTube URL
      /https?:\/\/(?:www\.)?youtube\.com\/shorts\/[\w-]+/i
      // YouTube Shorts URL
    ];
    const hasYoutubeUrl = youtubeUrlPatterns.some((pattern) => pattern.test(afterQuestionMark));
    if (hasYoutubeUrl) {
      return {
        question: questionText.substring(0, questionMarkIndex + 1).trim(),
        youtubeUrl: afterQuestionMark
      };
    }
    return { question: questionText };
  }
  /**
   * Detects if a question contains a DeFiLlama format after the question mark
   * @param questionText The question text to analyze
   * @returns Object containing the cleaned question and DeFiLlama protocol/metric info if present
   * @example 
   * detectDefiLlamaUrl("Will Uniswap TVL exceed $5B? df uniswap-v3 tvl");
   */
  static detectDefiLlamaUrl(questionText) {
    const questionMarkIndex = questionText.indexOf("?");
    if (questionMarkIndex === -1) {
      return { question: questionText };
    }
    const afterQuestionMark = questionText.substring(questionMarkIndex + 1).trim();
    if (!afterQuestionMark) {
      return { question: questionText };
    }
    const defillamaPattern = /^\s*df\s+(\S+(?:\s+\S+)*)\s+(\S+)\s*$/i;
    const match = afterQuestionMark.match(defillamaPattern);
    if (match && match[1] && match[2]) {
      const protocolParts = match[1].trim().split(/\s+/);
      const metric = match[2].trim();
      const protocol = protocolParts.join(" ");
      return {
        question: questionText.substring(0, questionMarkIndex + 1).trim(),
        protocol,
        metric
      };
    }
    return { question: questionText };
  }
  /**
   * Parse a private key from a string that could be a JSON array or base58 encoded
   * @param keyString Private key as JSON array or base58 string
   * @returns Uint8Array containing the private key bytes
   */
  static parseSecretKey(keyString) {
    try {
      const arr = JSON.parse(keyString);
      if (Array.isArray(arr)) {
        return Uint8Array.from(arr);
      }
    } catch {
    }
    try {
      return Uint8Array.from(import_bs58.default.decode(keyString));
    } catch {
    }
    throw new Error("Unable to parse private key. Provide a valid JSON array or base58 string.");
  }
  /**
   * Convert UI amount to raw amount based on decimals (defaults to 6 for USDC)
   * @param amount UI amount with decimal places
   * @param decimals Token decimals (default: 6 for USDC)
   * @returns Raw token amount as bigint
   */
  uiToRaw(amount, decimals = 6) {
    const scaleBI = 10n ** BigInt(decimals);
    const amtStr = String(amount);
    const [intPartRaw, fracPartRaw = ""] = amtStr.split(".");
    const intBI = intPartRaw ? BigInt(intPartRaw) : 0n;
    const fracPadded = (fracPartRaw + "0".repeat(decimals)).slice(0, decimals);
    const fracBI = fracPadded.length ? BigInt(fracPadded) : 0n;
    return intBI * scaleBI + fracBI;
  }
  /**
   * Buy tokens on a V3 market using USDC
   * @param params Buy parameters including market, side, and amount
   * @returns Transaction signature
   */
  async buyV3TokensUsdc(params) {
    const { market, buyYesToken, amountUsdc } = params;
    if (!this.anchorClient) {
      throw new Error(
        "AnchorClient not available. Initialize client with a signer."
      );
    }
    const amount = this.uiToRaw(amountUsdc);
    try {
      const program = this.anchorClient?.program;
      const marketAccount = await program.account.marketV3.fetch(market);
      const yesTokenMint = new import_web314.PublicKey(marketAccount.yesTokenMint);
      const noTokenMint = new import_web314.PublicKey(marketAccount.noTokenMint);
      const collateralTokenMint = new import_web314.PublicKey(marketAccount.collateralToken);
      const globalConfig = import_web314.PublicKey.findProgramAddressSync(
        [Buffer.from("global_config")],
        this.anchorClient.program.programId
      )[0];
      if (!this.signer || !this.signer.publicKey) {
        throw new Error("Signer not initialized properly");
      }
      const buyer = this.signer.publicKey;
      const buyerYesTokenAccount = await (0, import_spl_token6.getAssociatedTokenAddressSync)(
        yesTokenMint,
        buyer,
        false
      );
      const buyerNoTokenAccount = await (0, import_spl_token6.getAssociatedTokenAddressSync)(
        noTokenMint,
        buyer,
        false
      );
      const buyerCollateralTokenAccount = await (0, import_spl_token6.getAssociatedTokenAddressSync)(
        collateralTokenMint,
        buyer,
        false
      );
      const marketReserveVault = await (0, import_spl_token6.getAssociatedTokenAddressSync)(
        collateralTokenMint,
        market,
        true
        // allowOwnerOffCurve
      );
      const amountBN = new import_bn3.BN(amount.toString());
      const minimumOut = new import_bn3.BN(0);
      const result = await (this.anchorClient?.program).methods.buyV3Tokens(
        amountBN,
        { [buyYesToken ? "yes" : "no"]: {} },
        // side enum
        minimumOut
      ).accounts({
        buyer,
        market,
        globalConfig,
        yesTokenMint,
        noTokenMint,
        buyerYesTokenAccount,
        buyerNoTokenAccount,
        marketReserveVault,
        collateralTokenMint,
        buyerCollateralTokenAccount,
        tokenProgram: import_spl_token6.TOKEN_PROGRAM_ID,
        associatedTokenProgram: import_spl_token6.ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: import_web314.SystemProgram.programId
      }).rpc();
      return { signature: result };
    } catch (err) {
      if (err.logs) {
        const errorMsg = `buyV3TokensUsdc failed (amount_usdc=${amountUsdc}, side=${buyYesToken ? "yes" : "no"})
`;
        const logsStr = Array.isArray(err.logs) ? err.logs.join("\n") : String(err.logs);
        throw new Error(`${errorMsg}${logsStr}
Cause: ${err.message}`);
      }
      throw err;
    }
  }
  /**
   * Redeems a winning position in a resolved market
   * @param market - The public key of the market where the position was created
   * @param options - Optional parameters for customizing the redemption
   * @returns Transaction signature
   */
  async redeemPosition(market, options) {
    if (!this.redemption || !this.signer) {
      throw new Error("Redemption module not available. Make sure you initialized the client with a valid private key.");
    }
    if (!this.anchorClient) {
      throw new Error("Anchor client is not initialized. Cannot perform redemption.");
    }
    const marketData = await this.fetchMarket(market);
    const { account: marketAccount } = marketData;
    const { publicKey: globalConfigPDA } = await this.fetchGlobalConfig();
    const yesTokenMint = new import_web314.PublicKey(marketAccount.yes_token_mint);
    const noTokenMint = new import_web314.PublicKey(marketAccount.no_token_mint);
    const collateralTokenMint = new import_web314.PublicKey(marketAccount.collateral_token);
    const marketCreator = new import_web314.PublicKey(marketAccount.creator);
    const { account: globalConfigAccount } = await this.fetchGlobalConfig();
    const admin = options?.admin || new import_web314.PublicKey(globalConfigAccount.admin);
    const [yesAi, noAi, colAi] = await Promise.all([
      this.client.connection.getAccountInfo(yesTokenMint),
      this.client.connection.getAccountInfo(noTokenMint),
      this.client.connection.getAccountInfo(collateralTokenMint)
    ]);
    if (!yesAi || !noAi || !colAi) {
      throw new Error("One or more token mints are invalid");
    }
    const yesTokenProgram = yesAi.owner.equals(import_spl_token6.TOKEN_2022_PROGRAM_ID) ? import_spl_token6.TOKEN_2022_PROGRAM_ID : import_spl_token6.TOKEN_PROGRAM_ID;
    const noTokenProgram = noAi.owner.equals(import_spl_token6.TOKEN_2022_PROGRAM_ID) ? import_spl_token6.TOKEN_2022_PROGRAM_ID : import_spl_token6.TOKEN_PROGRAM_ID;
    const collateralTokenProgram = colAi.owner.equals(import_spl_token6.TOKEN_2022_PROGRAM_ID) ? import_spl_token6.TOKEN_2022_PROGRAM_ID : import_spl_token6.TOKEN_PROGRAM_ID;
    const buyer = this.signer.publicKey;
    const buyerYesTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      yesTokenMint,
      buyer,
      false,
      yesTokenProgram
    );
    const buyerNoTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      noTokenMint,
      buyer,
      false,
      noTokenProgram
    );
    const buyerCollateralTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      buyer,
      false,
      collateralTokenProgram
    );
    const marketReserveVault = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      market,
      true,
      collateralTokenProgram
    );
    const creatorFeeTreasury = options?.creatorFeeTreasury ? new import_web314.PublicKey(options.creatorFeeTreasury) : (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      marketCreator,
      false,
      collateralTokenProgram
    );
    const adminCollateralTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      admin,
      false,
      collateralTokenProgram
    );
    try {
      const result = await this.redemption.redeemPositionV2({
        buyer,
        market,
        admin,
        marketCreator,
        creatorFeeTreasury,
        adminCollateralTokenAccount,
        globalConfig: globalConfigPDA,
        yesTokenMint,
        noTokenMint,
        buyerYesTokenAccount,
        buyerNoTokenAccount,
        marketReserveVault,
        collateralTokenMint,
        buyerCollateralTokenAccount,
        tokenProgram: collateralTokenProgram,
        associatedTokenProgram: import_spl_token6.ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: import_web314.SystemProgram.programId
      });
      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error redeeming position: ${errorMessage}`);
    }
  }
  /**
   * Redeems a winning position in a resolved V3 market
   * @param market - The public key of the V3 market where the position was created
   * @returns Transaction signature
   */
  async redeemV3Position(market) {
    if (!this.signer) {
      throw new Error("Signer not available. Make sure you initialized the client with a valid private key.");
    }
    if (!this.anchorClient) {
      throw new Error("Anchor client is not initialized. Cannot perform redemption.");
    }
    const marketAccount = await this.anchorClient.program.account.marketV3.fetch(market);
    const [globalConfigPDA] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("global_config")],
      this.client.programId
    );
    const globalConfigAccount = await this.anchorClient.program.account.globalConfig.fetch(globalConfigPDA);
    const admin = new import_web314.PublicKey(globalConfigAccount.admin);
    const creator = new import_web314.PublicKey(marketAccount.creator);
    const yesTokenMint = new import_web314.PublicKey(marketAccount.yesTokenMint);
    const noTokenMint = new import_web314.PublicKey(marketAccount.noTokenMint);
    const collateralTokenMint = new import_web314.PublicKey(marketAccount.collateralToken);
    const redeemer = this.signer.publicKey;
    const redeemerYesTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      yesTokenMint,
      redeemer,
      false,
      import_spl_token6.TOKEN_PROGRAM_ID
    );
    const redeemerNoTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      noTokenMint,
      redeemer,
      false,
      import_spl_token6.TOKEN_PROGRAM_ID
    );
    const redeemerCollateralTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      redeemer,
      false,
      import_spl_token6.TOKEN_PROGRAM_ID
    );
    const marketReserveVault = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      market,
      true,
      import_spl_token6.TOKEN_PROGRAM_ID
    );
    const adminCollateralTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      admin,
      false,
      import_spl_token6.TOKEN_PROGRAM_ID
    );
    const [creatorFeeTreasury] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("creator_fee_treasury"), creator.toBuffer(), collateralTokenMint.toBuffer()],
      this.client.programId
    );
    try {
      const signature = await this.anchorClient.program.methods.redeemV3Position().accounts({
        redeemer,
        market,
        globalConfig: globalConfigPDA,
        yesTokenMint,
        noTokenMint,
        redeemerYesTokenAccount,
        redeemerNoTokenAccount,
        marketReserveVault,
        collateralTokenMint,
        redeemerCollateralTokenAccount,
        admin,
        adminCollateralTokenAccount,
        creatorFeeTreasury,
        tokenProgram: import_spl_token6.TOKEN_PROGRAM_ID,
        associatedTokenProgram: import_spl_token6.ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: import_web314.SystemProgram.programId
      }).rpc();
      return { signature };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error redeeming V3 position: ${errorMessage}`);
    }
  }
  /**
   * Redeem a winning position from a resolved P2P (V3) market.
   * Thin wrapper around redeemV3Position that accepts either a string or PublicKey.
   */
  async redeemP2PPosition(market) {
    const marketPk = typeof market === "string" ? new import_web314.PublicKey(market) : market;
    return this.redeemV3Position(marketPk);
  }
  // ===== Read-only helpers (no signer required) =====
  async fetchGlobalConfig() {
    const [pk] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("global_config")],
      this.client.programId
    );
    const ai = await this.client.connection.getAccountInfo(
      pk,
      this.client.commitment
    );
    if (!ai) throw new Error("global_config not found");
    const acc = decodeAccount("GlobalConfig", ai.data);
    return { publicKey: pk, account: acc };
  }
  /**
   * Set market resolvable status (V2 markets)
   * 
   *  DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
   * It will NOT work on mainnet. Use this only for development and testing.
   * 
   * @param market - Market public key or address string
   * @param resolvable - New resolvable status
   * @param forceResolve - Optional: force resolve (allow immediate refunds)
   * @returns Transaction signature
   */
  /**
   * Set market resolvable status for V2 markets.
   * Automatically handles market extension accounts for custom oracles.
   * 
   * @param market - Market public key or address string
   * @param resolvable - New resolvable status (true/false)
   * @param forceResolve - Optional: force resolve (allow immediate refunds)
   * @returns Transaction signature
   */
  async setMarketResolvable(market, resolvable, forceResolve) {
    if (!this.market) {
      throw new Error(
        "MarketModule required. Initialize client with a signer."
      );
    }
    const marketPk = typeof market === "string" ? new import_web314.PublicKey(market) : market;
    return this.market.setMarketResolvable({
      market: marketPk,
      resolvable,
      forceResolve
    });
  }
  /**
   * High-level method to create a V2 market with a custom oracle (settler).
   * 
   * @param params Market parameters including settler address and optional odds
   * @returns Created market details
   */
  async createMarketWithCustomOracle(params) {
    if (!this.anchorMarket) {
      throw new Error("AnchorMarket module not available");
    }
    return this.anchorMarket.createMarket({
      question: params.question,
      initialLiquidity: params.initialLiquidity,
      endTime: params.endTime,
      collateralTokenMint: params.collateralMint,
      oracle: params.settlerAddress,
      yesOddsBps: params.yesOddsBps
    });
  }
  /**
   * Set market resolvable status (V3/P2P markets)
   * 
   *  DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
   * It will NOT work on mainnet. Use this only for development and testing.
   * 
   * @param market - Market public key or address string
   * @param resolvable - New resolvable status
   * @returns Transaction signature
   */
  async setMarketResolvableP2p(market, resolvable) {
    if (!this.market) {
      throw new Error(
        "MarketModule not available. Initialize client with a signer."
      );
    }
    const marketPk = typeof market === "string" ? new import_web314.PublicKey(market) : market;
    return this.market.setMarketResolvableP2p({
      market: marketPk,
      resolvable
    });
  }
  async fetchMarket(market) {
    const ai = await this.client.connection.getAccountInfo(
      market,
      this.client.commitment
    );
    if (!ai) throw new Error("market account not found");
    const acc = decodeAccount("Market", ai.data);
    return { publicKey: market, account: acc };
  }
  async fetchMarkets() {
    const { createHash } = await import("crypto");
    const discriminator = createHash("sha256").update("account:Market").digest().subarray(0, 8);
    const filters = [
      { memcmp: { offset: 0, bytes: import_bs58.default.encode(Buffer.from(discriminator)) } }
    ];
    const ras = await this.client.connection.getProgramAccounts(
      this.client.programId,
      {
        commitment: this.client.commitment,
        filters
      }
    );
    const data = ras.map(({ pubkey, account }) => ({
      publicKey: pubkey.toBase58(),
      account: decodeAccount("Market", account.data)
    }));
    return { count: data.length, data };
  }
  // ===== Proxy server integration =====
  /**
   * Fetch settlement criteria for a market from the proxy server
   * @param market - Market public key (as string or PublicKey)
   * @param baseUrl - Optional base URL for the proxy server
   * @returns Settlement criteria data
   */
  async fetchSettlementCriteria(market, baseUrl) {
    const marketStr = typeof market === "string" ? market : market.toBase58();
    if (!marketStr || typeof marketStr !== "string") {
      throw new Error("A valid market address string is required.");
    }
    const proxyBaseUrl = baseUrl || process.env.PROXY_BASE_URL || "https://proxyserver-production-f61b.up.railway.app";
    const trimmed = proxyBaseUrl.replace(/\/+$/, "");
    const url = `${trimmed}/market-oracle/market/${encodeURIComponent(marketStr)}`;
    const res = await fetch(url, {
      method: "GET",
      headers: { "Content-Type": "application/json" }
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(
        `Proxy request failed (${res.status} ${res.statusText}): ${text}`
      );
    }
    const data = await res.json().catch(() => {
      throw new Error("Failed to parse JSON from proxy response");
    });
    if (data && typeof data === "object" && Object.prototype.hasOwnProperty.call(data, "data")) {
      return data.data;
    }
    return data;
  }
  /**
   * Get settlement criteria for a market from the proxy server (alias for fetchSettlementCriteria)
   * @param market - Market public key (as string or PublicKey)
   * @param baseUrl - Optional base URL for the proxy server
   * @returns Settlement criteria data
   */
  async getSettlementCriteria(market, baseUrl, options) {
    const RETRY_DELAY_MS = options?.retryDelayMs ?? 2e3;
    const MAX_RETRY_TIME_MS = options?.maxRetryTimeMs ?? 15 * 60 * 1e3;
    const startTime = Date.now();
    const sleep = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));
    let attempt = 1;
    while (Date.now() - startTime < MAX_RETRY_TIME_MS) {
      try {
        const result = await this.fetchSettlementCriteria(market, baseUrl);
        if (result !== null && typeof result !== "undefined") {
          return result;
        }
        await sleep(RETRY_DELAY_MS);
        attempt++;
      } catch (_err) {
        await sleep(RETRY_DELAY_MS);
        attempt++;
      }
    }
    throw new Error(
      `Timed out after ${Math.floor(MAX_RETRY_TIME_MS / 1e3)}s waiting for settlement criteria from proxy`
    );
  }
  /**
   * Convenience helper: wait for settlement criteria and provide a small summary.
   * - Uses getSettlementCriteria() (with retry) under the hood
   * - Derives a friendly YES/NO answer when possible
   * - Surfaces resolvable if provided by the proxy
   */
  async waitForSettlementCriteria(market, baseUrl, options) {
    const criteria = await this.getSettlementCriteria(market, baseUrl, options);
    let answer;
    const anyCrit = criteria;
    if (typeof anyCrit?.answer === "string" && anyCrit.answer.length > 0) {
      answer = String(anyCrit.answer).toUpperCase();
    } else if (typeof anyCrit?.winning_token_id === "string") {
      const w = String(anyCrit.winning_token_id).toLowerCase();
      if (w === "yes" || w === "no") answer = w.toUpperCase();
      else answer = String(anyCrit.winning_token_id);
    }
    const resolvable = typeof anyCrit?.resolvable === "boolean" ? Boolean(anyCrit.resolvable) : void 0;
    return { resolvable, answer, criteria };
  }
  /**
   * Fetch settlement data for a market from the proxy server
   * @param market - Market public key (as string or PublicKey)
   * @param baseUrl - Optional base URL for the proxy server
   * @returns Settlement data
   */
  async fetchSettlementData(market, baseUrl) {
    const marketStr = typeof market === "string" ? market : market.toBase58();
    if (!marketStr || typeof marketStr !== "string") {
      throw new Error("A valid market address string is required.");
    }
    const proxyBaseUrl = baseUrl || process.env.PROXY_BASE_URL || "https://proxyserver-production-f61b.up.railway.app";
    const trimmed = proxyBaseUrl.replace(/\/+$/, "");
    const url = `${trimmed}/market-oracle/market/${encodeURIComponent(marketStr)}/settlement-data`;
    const res = await fetch(url, {
      method: "GET",
      headers: { "Content-Type": "application/json" }
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(
        `Proxy request failed (${res.status} ${res.statusText}): ${text}`
      );
    }
    const data = await res.json().catch(() => {
      throw new Error("Failed to parse JSON from proxy response");
    });
    const responseData = data && typeof data === "object" && Object.prototype.hasOwnProperty.call(data, "data") ? data.data : data;
    const result = {
      answer: "",
      reasoning: "",
      ...responseData
    };
    if (!result.answer && responseData) {
      if (responseData.winning_token_id === "yes") {
        result.answer = "YES";
      } else if (responseData.winning_token_id === "no") {
        result.answer = "NO";
      } else if (responseData.winning_token_id) {
        result.answer = responseData.winning_token_id.toUpperCase();
      }
    }
    if (!result.reasoning && responseData && responseData.settlement_description) {
      result.reasoning = responseData.settlement_description;
    }
    return result;
  }
  /**
   * Get settlement data for a market from the proxy server (alias for fetchSettlementData)
   * @param market - Market public key (as string or PublicKey)
   * @param baseUrl - Optional base URL for the proxy server
   * @returns Settlement data
   */
  async getSettlementData(market, baseUrl) {
    return this.fetchSettlementData(market, baseUrl);
  }
  /**
   * Fetch market addresses from the proxy server
   * @param baseUrl - Optional base URL for the proxy server
   * @returns Array of market addresses
   */
  async fetchMarketAddresses(baseUrl) {
    const proxyBaseUrl = baseUrl || process.env.PROXY_BASE_URL || "https://proxyserver-production-f61b.up.railway.app";
    const trimmed = proxyBaseUrl.replace(/\/+$/, "");
    const url = `${trimmed}/market-oracle/market-addresses`;
    const res = await fetch(url, {
      method: "GET",
      headers: { "Content-Type": "application/json" }
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(
        `Proxy request failed (${res.status} ${res.statusText}): ${text}`
      );
    }
    const data = await res.json().catch(() => {
      throw new Error("Failed to parse JSON from proxy response");
    });
    if (Array.isArray(data)) return data.map(String);
    if (data && Array.isArray(data.addresses))
      return data.addresses.map(String);
    if (data && typeof data.success !== "undefined" && data.data && Array.isArray(data.data.addresses)) {
      return data.data.addresses.map(String);
    }
    if (data && Array.isArray(data.data)) return data.data.map(String);
    throw new Error(
      "Unexpected proxy response shape. Expected array, {addresses: string[]}, {data: string[]}, or { success, data: { addresses: string[] } }."
    );
  }
  /**
   * Get comprehensive information for a P2P market (V3), including reserves, token mints, and settlement criteria
   * @param marketAddress Market address as PublicKey or string
   * @param options Optional parameters like base URL
   * @returns Combined market info with both on-chain data and settlement criteria
   */
  async getP2PMarketInfo(marketAddress, options) {
    const marketKey = typeof marketAddress === "string" ? new import_web314.PublicKey(marketAddress) : marketAddress;
    let marketAccount;
    if (this.anchorClient) {
      try {
        marketAccount = await this.anchorClient.program.account.marketV3.fetch(marketKey);
      } catch (error) {
        console.warn("Error fetching via Anchor client, falling back to connection", error);
      }
    }
    if (!marketAccount) {
      const accountInfo = await this.client.connection.getAccountInfo(marketKey);
      if (!accountInfo) {
        throw new Error(`Market account not found: ${marketKey.toString()}`);
      }
      try {
        marketAccount = this.decodeMarketAny(accountInfo.data);
      } catch (error) {
        throw new Error(`Failed to decode market data: ${error}`);
      }
    }
    const settlementCriteria = await this.fetchSettlementCriteria(marketKey.toString(), options?.baseUrl).catch(() => null);
    let yesMint = "0";
    let noMint = "0";
    try {
      yesMint = (marketAccount.yesTokenMint || marketAccount.yes_token_mint)?.toString() || "0";
      noMint = (marketAccount.noTokenMint || marketAccount.no_token_mint)?.toString() || "0";
    } catch (error) {
      console.warn("Error accessing mint addresses:", error);
    }
    let yesReserve = "0";
    let noReserve = "0";
    try {
      yesReserve = (marketAccount.yesPotReserve || marketAccount.yes_pot_reserve)?.toString() || "0";
      noReserve = (marketAccount.noPotReserve || marketAccount.no_pot_reserve)?.toString() || "0";
    } catch (error) {
      console.warn("Error accessing reserve values:", error);
    }
    let endTime = /* @__PURE__ */ new Date();
    try {
      const endTimeSeconds = Number(marketAccount.endTime || marketAccount.end_time || 0);
      endTime = new Date(endTimeSeconds * 1e3);
    } catch (error) {
      console.warn("Error accessing end time:", error);
    }
    let collateralMint = "0";
    try {
      collateralMint = (marketAccount.collateralToken || marketAccount.collateral_token)?.toString() || "0";
    } catch (error) {
      console.warn("Error accessing collateral mint:", error);
    }
    let question = "";
    try {
      question = (marketAccount.question || marketAccount.question)?.toString() || "";
    } catch (error) {
      console.warn("Error accessing question:", error);
    }
    return {
      question,
      yesMint,
      noMint,
      yesReserve,
      noReserve,
      collateralMint,
      settlementCriteria,
      endTime
    };
  }
  /**
   * Get comprehensive market information for a V2 market, combining on-chain data and settlement criteria
   * @param marketAddress Market address as PublicKey or string
   * @param options Optional parameters like base URL
   * @returns Combined market info with both on-chain data and settlement criteria
   */
  async getV2MarketInfo(marketAddress, options) {
    const marketKey = typeof marketAddress === "string" ? new import_web314.PublicKey(marketAddress) : marketAddress;
    const { account: marketAccount } = await this.fetchMarket(marketKey);
    const settlementCriteria = await this.fetchSettlementCriteria(marketKey.toString(), options?.baseUrl).catch(() => null);
    let yesMultiplier = 1;
    let noMultiplier = 1;
    const endTimeSeconds = Number(marketAccount.end_time);
    const endTime = new Date(endTimeSeconds * 1e3);
    return {
      yesMint: marketAccount.yes_token_mint.toString(),
      noMint: marketAccount.no_token_mint.toString(),
      question: marketAccount.question,
      creator: marketAccount.creator.toString(),
      settlementCriteria,
      yesMultiplier,
      noMultiplier,
      endTime
    };
  }
  /**
   * Fetch V3 market addresses from the proxy server
   * @param baseUrl - Optional base URL for the proxy server
   * @returns Array of market addresses
   */
  async fetchV3MarketAddresses(baseUrl) {
    const proxyBaseUrl = baseUrl || process.env.PROXY_BASE_URL || "https://proxyserver-production-f61b.up.railway.app";
    const trimmed = proxyBaseUrl.replace(/\/+$/, "");
    const url = `${trimmed}/market-oracle/v3-market-addresses`;
    const res = await fetch(url, {
      method: "GET",
      headers: { "Content-Type": "application/json" }
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(
        `Proxy request failed (${res.status} ${res.statusText}): ${text}`
      );
    }
    const data = await res.json().catch(() => {
      throw new Error("Failed to parse JSON from proxy response");
    });
    if (Array.isArray(data)) return data.map(String);
    if (data && Array.isArray(data.addresses))
      return data.addresses.map(String);
    if (data && typeof data.success !== "undefined" && data.data && Array.isArray(data.data.addresses)) {
      return data.data.addresses.map(String);
    }
    if (data && Array.isArray(data.data)) return data.data.map(String);
    throw new Error(
      "Unexpected proxy response shape. Expected array, {addresses: string[]}, {data: string[]}, or { success, data: { addresses: string[] } }."
    );
  }
  /**
   * Get market metadata (volume, image, initial liquidity) for multiple markets in a single API call
   * @param markets - Array of market public keys (as strings or PublicKeys)
   * @param baseUrl - Optional base URL for the proxy server
   * @returns Array of market metadata including volume, image, and initial liquidity
   */
  async getMarketMetaBatch(markets, baseUrl) {
    if (!markets || !Array.isArray(markets) || markets.length === 0) {
      throw new Error("At least one market address is required.");
    }
    const addresses = markets.map(
      (m) => typeof m === "string" ? m : m.toBase58()
    );
    const proxyBaseUrl = baseUrl || process.env.PROXY_BASE_URL || "https://proxyserver-production-f61b.up.railway.app";
    const trimmed = proxyBaseUrl.replace(/\/+$/, "");
    const url = `${trimmed}/market-oracle/batch-data`;
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ addresses })
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(
        `Proxy request failed (${res.status} ${res.statusText}): ${text}`
      );
    }
    const data = await res.json().catch(() => {
      throw new Error("Failed to parse JSON from proxy response");
    });
    if (data && data.success === false) {
      throw new Error(data.error || "Unknown error from proxy server");
    }
    if (!data || !data.data || !Array.isArray(data.data)) {
      throw new Error("Invalid response format from proxy server");
    }
    return data.data;
  }
  /**
   * Get market metadata (volume, image, initial liquidity) for a single market
   * @param market - Market public key (as string or PublicKey)
   * @param baseUrl - Optional base URL for the proxy server
   * @returns Market metadata including volume, image, and initial liquidity
   */
  async getMarketMeta(market, baseUrl) {
    const results = await this.getMarketMetaBatch([market], baseUrl);
    const result = results[0];
    if (!result) {
      const marketStr = typeof market === "string" ? market : market.toBase58();
      throw new Error(`No metadata found for market: ${marketStr}`);
    }
    return result;
  }
  /**
   * Claim creator refund for a market.
   * Behavior parity with scripts/claimCreatorRefund.ts:
   * - Eligible if market is not resolvable (proxy or on-chain flag) AND signer is the creator
   * - Mixed token programs => use creator_refund_v2 with accountsPartial (yes/no token mints null)
   * - Uniform token programs => try creator_refund_v2 then fallback to v1
   */
  async claimMarketRefund(market) {
    if (!this.redemption || !this.trading) {
      throw new Error(
        "Required modules (redemption and trading) are undefined. Ensure your wallet secret is valid."
      );
    }
    const info = await this.trading.getMarketInfo(market);
    let isNotResolvable = false;
    if (info && typeof info.resolvable === "boolean") {
      isNotResolvable = !info.resolvable;
    } else {
      try {
        const criteria = await this.fetchSettlementCriteria(
          market.toBase58()
        );
        if (criteria && typeof criteria.resolvable === "boolean") {
          isNotResolvable = !criteria.resolvable;
        }
      } catch {
      }
    }
    const walletPk = this.signer?.publicKey;
    const isCreator = walletPk ? walletPk.equals(info.creator) : false;
    if (!(isNotResolvable && isCreator)) {
      throw new Error(
        "This market is not eligible for creator refund. Must be not resolvable and you must be the creator."
      );
    }
    const yesMint = info.yesTokenMint;
    const noMint = info.noTokenMint;
    const collateralMint = info.collateralToken;
    const creator = info.creator;
    if (!collateralMint || !creator) {
      throw new Error(
        "Market is missing required collateral token or creator info"
      );
    }
    const [yesAi, noAi, colAi] = await Promise.all([
      this.client.connection.getAccountInfo(yesMint),
      this.client.connection.getAccountInfo(noMint),
      this.client.connection.getAccountInfo(collateralMint)
    ]);
    if (!yesAi || !noAi || !colAi)
      throw new Error("One or more market mint accounts are missing");
    const hasUniformTokenProgram = yesAi.owner.equals(noAi.owner) && yesAi.owner.equals(colAi.owner);
    const collateralTokenProgram = colAi.owner.equals(import_spl_token6.TOKEN_2022_PROGRAM_ID) ? import_spl_token6.TOKEN_2022_PROGRAM_ID : import_spl_token6.TOKEN_PROGRAM_ID;
    const [globalConfig] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("global_config")],
      this.client.programId
    );
    const marketReserveVault = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralMint,
      market,
      true,
      collateralTokenProgram
    );
    const creatorCollateralTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralMint,
      creator,
      false,
      collateralTokenProgram
    );
    if (!hasUniformTokenProgram) {
      if (!this.anchorClient) {
        throw new Error(
          "Anchor client is not initialized. Cannot perform creator refund."
        );
      }
      const tx = await this.anchorClient.program.methods.creatorRefundV2().accountsPartial({
        creator,
        globalConfig,
        market,
        yesTokenMint: null,
        noTokenMint: null,
        marketReserveVault,
        collateralTokenMint: collateralMint,
        creatorCollateralTokenAccount,
        tokenProgram: collateralTokenProgram,
        associatedTokenProgram: import_spl_token6.ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: import_web314.SystemProgram.programId
      }).rpc();
      return { signature: tx };
    }
    try {
      const res = await this.redemption.creatorRefundV2({
        creator,
        global_config: globalConfig,
        market,
        yes_token_mint: yesMint,
        no_token_mint: noMint,
        market_reserve_vault: marketReserveVault,
        collateral_token_mint: collateralMint,
        creator_collateral_token_account: creatorCollateralTokenAccount,
        token_program: collateralTokenProgram,
        associated_token_program: import_spl_token6.ASSOCIATED_TOKEN_PROGRAM_ID,
        system_program: import_web314.SystemProgram.programId
      });
      return { signature: res.signature ?? res };
    } catch (e) {
      const res = await this.redemption.creatorRefund({
        creator,
        global_config: globalConfig,
        market,
        yes_token_mint: yesMint,
        no_token_mint: noMint,
        market_reserve_vault: marketReserveVault,
        collateral_token_mint: collateralMint,
        creator_collateral_token_account: creatorCollateralTokenAccount,
        token_program: collateralTokenProgram,
        associated_token_program: import_spl_token6.ASSOCIATED_TOKEN_PROGRAM_ID,
        system_program: import_web314.SystemProgram.programId
      });
      return { signature: res.signature ?? res };
    }
  }
  /**
   * Claim creator refund for a P2P (V3) market by market address.
   * - Uses getP2PMarketInfo to discover collateral mint
   * - Decodes MarketV3 to discover creator
   * - Enforces that the signer is the creator
   * - Automatically wires all required PDAs and token accounts
   */
  async claimP2PMarketRefund(marketAddress) {
    if (!this.redemption) {
      throw new Error(
        "Redemption module not available. Ensure your wallet secret is valid."
      );
    }
    if (!this.anchorClient) {
      throw new Error(
        "Anchor client not available. Ensure your wallet secret is valid."
      );
    }
    if (!this.signer || !this.signer.publicKey) {
      throw new Error(
        "Signer not available. Initialize PNPClient with a valid private key."
      );
    }
    const market = typeof marketAddress === "string" ? new import_web314.PublicKey(marketAddress) : marketAddress;
    const marketInfo = await this.getP2PMarketInfo(market);
    const collateralTokenMint = new import_web314.PublicKey(marketInfo.collateralMint);
    const [globalConfig] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("global_config")],
      this.anchorClient.program.programId
    );
    const accountInfo = await this.client.connection.getAccountInfo(market);
    if (!accountInfo) {
      throw new Error(`Market account not found: ${market.toBase58()}`);
    }
    const marketData = decodeAccount(
      "MarketV3",
      accountInfo.data
    );
    const creator = marketData.creator instanceof import_web314.PublicKey ? marketData.creator : new import_web314.PublicKey(marketData.creator);
    if (!this.signer.publicKey.equals(creator)) {
      throw new Error("Signer is not the creator of this P2P market");
    }
    const mintInfo = await this.client.connection.getAccountInfo(
      collateralTokenMint
    );
    if (!mintInfo) {
      throw new Error("Collateral mint account not found");
    }
    const tokenProgramId = mintInfo.owner.equals(import_spl_token6.TOKEN_2022_PROGRAM_ID) ? import_spl_token6.TOKEN_2022_PROGRAM_ID : import_spl_token6.TOKEN_PROGRAM_ID;
    const marketReserveVault = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      market,
      true,
      tokenProgramId
    );
    const creatorCollateralTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      creator,
      false,
      tokenProgramId
    );
    const res = await this.redemption.creatorRefundV3({
      creator,
      global_config: globalConfig,
      market,
      market_reserve_vault: marketReserveVault,
      collateral_token_mint: collateralTokenMint,
      creator_collateral_token_account: creatorCollateralTokenAccount,
      token_program: tokenProgramId,
      associated_token_program: import_spl_token6.ASSOCIATED_TOKEN_PROGRAM_ID,
      system_program: import_web314.SystemProgram.programId
    });
    return { signature: res.signature };
  }
  /**
   * Settle a V2 market by determining the winning outcome.
   * Only callable by the oracle/admin after market is resolvable.
   * 
   * @param params Market address and outcome (true for YES winner, false for NO winner)
   * @returns Transaction signature
   */
  async settleMarket(params) {
    if (!this.anchorClient || !this.signer) {
      throw new Error("AnchorClient and signer required for settleMarket");
    }
    const { market, yesWinner } = params;
    const marketData = await this.anchorClient.program.account.market.fetch(market);
    const collateralTokenMint = marketData.collateralToken;
    const marketCreator = marketData.creator;
    const marketId = marketData.id;
    const [globalConfig] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("global_config")],
      this.anchorClient.program.programId
    );
    const globalConfigData = await this.anchorClient.program.account.globalConfig.fetch(globalConfig);
    const admin = globalConfigData.admin;
    const gidLe = marketId.toArrayLike(Buffer, "le", 8);
    const [yesTokenMint] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("yes_token"), gidLe],
      this.anchorClient.program.programId
    );
    const [noTokenMint] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("no_token"), gidLe],
      this.anchorClient.program.programId
    );
    const marketReserveVault = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      market,
      true
    );
    const buyerYesTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      yesTokenMint,
      this.signer.publicKey
    );
    const buyerNoTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      noTokenMint,
      this.signer.publicKey
    );
    const buyerCollateralTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      this.signer.publicKey
    );
    const adminCollateralTokenAccount = (0, import_spl_token6.getAssociatedTokenAddressSync)(
      collateralTokenMint,
      admin
    );
    const [creatorFeeTreasury] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("creator_fee_treasury"), marketCreator.toBuffer(), collateralTokenMint.toBuffer()],
      this.anchorClient.program.programId
    );
    const [marketExtension] = import_web314.PublicKey.findProgramAddressSync(
      [Buffer.from("market_ext"), gidLe],
      this.anchorClient.program.programId
    );
    const extensionInfo = await this.connection.getAccountInfo(marketExtension);
    const txSignature = await this.anchorClient.program.methods.settleMarket(yesWinner).accounts({
      buyer: this.signer.publicKey,
      admin,
      marketCreator,
      market,
      globalConfig,
      yesTokenMint,
      noTokenMint,
      buyerYesTokenAccount,
      buyerNoTokenAccount,
      marketReserveVault,
      collateralTokenMint,
      buyerCollateralTokenAccount,
      adminCollateralTokenAccount,
      creatorFeeTreasury,
      marketExtension: extensionInfo ? marketExtension : null,
      tokenProgram: import_spl_token6.TOKEN_PROGRAM_ID,
      associatedTokenProgram: import_spl_token6.ASSOCIATED_TOKEN_PROGRAM_ID,
      systemProgram: import_web314.SystemProgram.programId
    }).signers([this.anchorClient.signer]).rpc();
    return { signature: txSignature };
  }
};

// src/cli.ts
var import_bs582 = __toESM(require("bs58"), 1);
var fs = __toESM(require("fs"), 1);
var path = __toESM(require("path"), 1);
function usage(code = 0) {
  console.log(`
PNP CLI

Usage:
  pnp create market "<question>" [--liquidity <lamports>] [--end <iso|days>]
  pnp trade <marketId> buy <YES|NO> <amount_usdc>
  pnp trade <marketId> sell <YES|NO> <amount_base_units>
  pnp trade <marketId> balance
  pnp trade <marketId> prices
  pnp status <marketId>
  pnp fetchMarkets
  pnp settlementCritera <marketId>

Env:
  RPC_URL, WALLET_SECRET_ARRAY | WALLET_BS58 | WALLET_FILE, [PNP_IDL_PATH]
`);
  process.exit(code);
}
function parseWalletFromEnv() {
  const secretArr = process.env.WALLET_SECRET_ARRAY;
  if (secretArr) {
    try {
      const arr = JSON.parse(secretArr);
      if (!Array.isArray(arr)) throw new Error("not an array");
      return import_web315.Keypair.fromSecretKey(Uint8Array.from(arr));
    } catch (e) {
      throw new Error("WALLET_SECRET_ARRAY must be a JSON array of numbers");
    }
  }
  const secretBs58 = process.env.WALLET_BS58;
  if (secretBs58) {
    try {
      const bytes = import_bs582.default.decode(secretBs58);
      return import_web315.Keypair.fromSecretKey(Uint8Array.from(bytes));
    } catch (e) {
      throw new Error("WALLET_BS58 must be a valid base58-encoded secret key");
    }
  }
  const walletFile = process.env.WALLET_FILE;
  if (walletFile) {
    try {
      const resolved = walletFile.startsWith("~") ? path.join(process.env.HOME || "", walletFile.slice(1)) : path.resolve(walletFile);
      const content = fs.readFileSync(resolved, "utf8");
      const parsed = JSON.parse(content);
      if (!Array.isArray(parsed)) {
        throw new Error("Expected JSON array in WALLET_FILE");
      }
      return import_web315.Keypair.fromSecretKey(Uint8Array.from(parsed));
    } catch (e) {
      throw new Error(`Failed to read WALLET_FILE: ${e?.message || e}`);
    }
  }
  throw new Error("Wallet not provided. Set one of WALLET_SECRET_ARRAY (JSON array), WALLET_BS58 (base58), or WALLET_FILE (path to JSON array).");
}
function hexToBigInt(hex) {
  return BigInt("0x" + hex);
}
function hexToNumberSafe(hex) {
  const n = hexToBigInt(hex);
  return n > BigInt(Number.MAX_SAFE_INTEGER) ? null : Number(n);
}
function hexUnixSecondsToISOString(hex) {
  const seconds = Number(hexToBigInt(hex));
  return new Date(seconds * 1e3).toISOString();
}
var DEFAULT_PROXY_BASE_URL = "https://proxyserver-production-f61b.up.railway.app";
var MARKET_ADDRESSES_ENDPOINT = "/market-oracle/market-addresses";
async function fetchMarketAddressesFromProxy(baseUrl = process.env.PROXY_BASE_URL || DEFAULT_PROXY_BASE_URL) {
  const trimmed = baseUrl.replace(/\/+$/, "");
  const url = `${trimmed}${MARKET_ADDRESSES_ENDPOINT}`;
  const res = await fetch(url, {
    method: "GET",
    headers: { "Content-Type": "application/json" }
  });
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`Proxy request failed (${res.status} ${res.statusText}): ${text}`);
  }
  const data = await res.json().catch(() => {
    throw new Error("Failed to parse JSON from proxy response");
  });
  if (Array.isArray(data)) return data.map(String);
  if (data && Array.isArray(data.addresses)) return data.addresses.map(String);
  if (data && typeof data.success !== "undefined" && data.data && Array.isArray(data.data.addresses)) {
    return data.data.addresses.map(String);
  }
  if (data && Array.isArray(data.data)) return data.data.map(String);
  throw new Error("Unexpected proxy response shape. Expected array, {addresses: string[]}, {data: string[]}, or { success, data: { addresses: string[] } }.");
}
async function main() {
  const args = process.argv.slice(2);
  if (args.length === 0) usage(1);
  const [cmd, subcmd, ...rest] = args;
  if (cmd === "fetchMarkets") {
    const base = process.env.PROXY_BASE_URL || DEFAULT_PROXY_BASE_URL;
    const addresses = await fetchMarketAddressesFromProxy(base);
    if (!addresses.length) {
      console.log("\nNo market addresses returned by the proxy.");
      return;
    }
    console.log(`
Received ${addresses.length} market addresses:`);
    for (const addr of addresses) console.log(addr);
    return;
  }
  if (cmd === "settlementCritera") {
    const marketStr = subcmd;
    if (!marketStr) {
      usage(1);
    }
    const rpcUrlForReadOnly = process.env.RPC_URL || "https://api.mainnet-beta.solana.com";
    const sdkReadOnly = new PNPClient(rpcUrlForReadOnly);
    const criteria = await sdkReadOnly.getSettlementCriteria(marketStr);
    console.log(JSON.stringify(criteria, null, 2));
    return;
  }
  const rpcUrl = process.env.RPC_URL;
  if (!rpcUrl) throw new Error("RPC_URL must be set");
  const signer = parseWalletFromEnv();
  const sdk = new PNPClient(rpcUrl, signer.secretKey);
  if (cmd === "create" && (subcmd === "market" || !subcmd)) {
    let question = rest.join(" ").trim();
    const qi = args.findIndex((a) => a === "--question" || a === "-q");
    if (!question && qi >= 0) {
      const flagVal = args[qi + 1];
      if (typeof flagVal === "string" && flagVal.length > 0) {
        question = flagVal;
      }
    }
    if (!question || question.length === 0) {
      console.error("Missing question");
      usage(1);
    }
    const questionStr = question;
    const liIdx = args.findIndex((a) => a === "--liquidity" || a === "-l");
    const initialLiquidityNum = liIdx >= 0 && args[liIdx + 1] ? Number(args[liIdx + 1]) : 5e7;
    if (!Number.isFinite(initialLiquidityNum) || initialLiquidityNum <= 0) {
      throw new Error("Invalid --liquidity value");
    }
    const initialLiquidity = BigInt(Math.floor(initialLiquidityNum));
    let endDate = new Date(Date.now() + 7 * 24 * 3600 * 1e3);
    const endIdx = args.findIndex((a) => a === "--end");
    const daysIdx = args.findIndex((a) => a === "--days");
    if (endIdx >= 0 && typeof args[endIdx + 1] === "string") {
      const d = new Date(args[endIdx + 1]);
      if (isNaN(d.getTime())) throw new Error("Invalid --end date");
      endDate = d;
    } else if (daysIdx >= 0 && typeof args[daysIdx + 1] === "string") {
      const days = Number(args[daysIdx + 1]);
      if (!Number.isFinite(days) || days <= 0) throw new Error("Invalid --days value");
      endDate = new Date(Date.now() + days * 24 * 3600 * 1e3);
    }
    const endTime = BigInt(Math.floor(endDate.getTime() / 1e3));
    const COLLATERAL_TOKEN_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
    const collateralTokenMint = new import_web315.PublicKey(COLLATERAL_TOKEN_MINT);
    const res = await sdk.anchorMarket.createMarket({ question: questionStr, initialLiquidity, endTime, collateralTokenMint });
    const md = res.marketDetails;
    if (md && typeof md === "object") {
      const decoded = {
        id: md.id,
        resolved: md.resolved,
        marketReserves: typeof md.marketReserves === "string" ? hexToNumberSafe(md.marketReserves) : md.marketReserves,
        initialLiquidity: typeof md.initialLiquidity === "string" ? hexToNumberSafe(md.initialLiquidity) : md.initialLiquidity,
        yesTokenSupplyMinted: typeof md.yesTokenSupplyMinted === "string" ? hexToNumberSafe(md.yesTokenSupplyMinted) : md.yesTokenSupplyMinted,
        noTokenSupplyMinted: typeof md.noTokenSupplyMinted === "string" ? hexToNumberSafe(md.noTokenSupplyMinted) : md.noTokenSupplyMinted,
        endTime: typeof md.endTime === "string" ? hexUnixSecondsToISOString(md.endTime) : md.endTime,
        creationTime: typeof md.creationTime === "string" ? hexUnixSecondsToISOString(md.creationTime) : md.creationTime,
        collateralToken: md.collateralToken,
        creator: md.creator,
        creatorFeeTreasury: md.creatorFeeTreasury,
        resolvable: md.resolvable,
        forceResolve: md.forceResolve,
        winningTokenId: md.winningTokenId
      };
      console.log("\nDecoded Market Details:");
      console.log("------------------------");
      Object.entries(decoded).forEach(([k, v]) => {
        console.log(`${k}: ${typeof v === "object" ? JSON.stringify(v) : v}`);
      });
      console.log("------------------------\n");
    }
    if (md && typeof md === "object") {
      const { yesTokenMint, noTokenMint, ...mdSansMints } = md;
      const sanitized = { success: true, ...res, marketDetails: mdSansMints };
      console.log(JSON.stringify(sanitized, null, 2));
    } else {
      console.log(JSON.stringify({ success: true, ...res }, null, 2));
    }
    return;
  }
  if (cmd === "status") {
    const marketStr = subcmd;
    if (!marketStr) {
      usage(1);
    }
    const marketPk = new import_web315.PublicKey(marketStr);
    const info = await sdk.trading.getMarketInfo(marketPk);
    const rawEnd = info.endTime;
    let endSec = null;
    if (typeof rawEnd === "bigint") endSec = Number(rawEnd);
    else if (typeof rawEnd === "number") endSec = rawEnd;
    else if (typeof rawEnd === "string") {
      const hex = /^[0-9a-fA-F]+$/.test(rawEnd);
      try {
        endSec = Number(hex ? BigInt("0x" + rawEnd) : BigInt(rawEnd));
      } catch {
        const n = Number(rawEnd);
        endSec = Number.isFinite(n) ? n : null;
      }
    }
    const nowSec = Math.floor(Date.now() / 1e3);
    const ended = endSec !== null ? nowSec >= endSec : false;
    const endIso = endSec ? new Date(endSec * 1e3).toISOString() : "unknown";
    console.log("Market Status:");
    console.log("--------------");
    console.log(`market: ${info.address.toBase58()}`);
    console.log(`resolvable: ${info.resolvable}`);
    console.log(`resolved: ${info.resolved}`);
    console.log(`tradable: ${info.resolvable === true && info.resolved === false && !ended}`);
    if (endSec !== null) {
      console.log(`endTimeSeconds: ${endSec}`);
      console.log(`endTimeISO: ${endIso}`);
    }
    console.log(`ended: ${ended}`);
    console.log("--------------");
    return;
  }
  if (cmd === "trade") {
    if (!subcmd) {
      usage(1);
    }
    const marketStr = subcmd;
    const action = (rest[0] || "").toLowerCase();
    const side = (rest[1] || "").toUpperCase();
    const amountArg = rest[2];
    const marketPk = new import_web315.PublicKey(marketStr);
    if (action === "balance") {
      const bals = await sdk.trading.getBalances(marketPk);
      console.log("Balances:");
      console.log(`  USDC: ${bals.collateral.uiAmountString}`);
      console.log(`  YES: ${bals.yes.uiAmountString}`);
      console.log(`  NO:  ${bals.no.uiAmountString}`);
      return;
    }
    if (action === "prices") {
      const p = await sdk.trading.getPrices(marketPk);
      console.log("Prices (implied shares):");
      console.log(`  YES share: ${(p.yesShare * 100).toFixed(2)}%`);
      console.log(`  NO  share: ${(p.noShare * 100).toFixed(2)}%`);
      return;
    }
    if (!marketStr || action !== "buy" && action !== "sell" || side !== "YES" && side !== "NO") {
      console.error("Usage: pnp trade <marketId> buy <YES|NO> <amount_usdc> | pnp trade <marketId> sell <YES|NO> <amount_base_units> | pnp trade <marketId> balance | pnp trade <marketId> prices");
      usage(1);
    }
    if (action === "buy") {
      if (!amountArg) {
        console.error("Missing amount_usdc");
        usage(1);
      }
      const amtUsdc = Number(amountArg);
      if (!Number.isFinite(amtUsdc) || amtUsdc <= 0) {
        console.error("Invalid amount_usdc");
        usage(1);
      }
      const buyYesToken = side === "YES";
      console.log(`\u{1F6D2} Buying ${side} with ${amtUsdc} USDC on ${marketPk.toBase58()} ...`);
      const res = await sdk.trading.buyTokensUsdc({ market: marketPk, buyYesToken, amountUsdc: amtUsdc, minimumOut: 0n });
      console.log(`\u2705 Trade submitted: ${res.signature}`);
      console.log(`\u{1F4B8} USDC Spent: ${res.usdcSpent}`);
      console.log(`\u{1F3AF} ${side} Tokens Received: ${res.tokensReceived}`);
      return;
    } else {
      if (!amountArg) {
        console.error("Missing amount_base_units");
        usage(1);
      }
      const amtBase = BigInt(amountArg);
      if (amtBase <= 0n) {
        console.error("Invalid amount_base_units");
        usage(1);
      }
      const burnYesToken = side === "YES";
      console.log(`\u{1F3EA} Selling ${side} amount=${amtBase.toString()} (base units) on ${marketPk.toBase58()} ...`);
      const res = await sdk.trading.sellTokensBase({ market: marketPk, burnYesToken, amountBaseUnits: amtBase });
      console.log(`\u2705 Trade submitted: ${res.signature}`);
      console.log(`\u{1F3EA} ${side} Tokens Sold: ${res.tokensSold}`);
      console.log(`\u{1F4B0} USDC Received: ${res.usdcReceived}`);
      return;
    }
  }
  usage(1);
}
main().catch((err) => {
  console.error(err?.message || err);
  process.exit(1);
});
//# sourceMappingURL=cli.cjs.map