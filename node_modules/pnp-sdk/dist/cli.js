#!/usr/bin/env node
import {
  PNPClient
} from "./chunk-HN2SKUTC.js";

// src/cli.ts
import "dotenv/config";
import { Keypair, PublicKey } from "@solana/web3.js";
import bs58 from "bs58";
import * as fs from "fs";
import * as path from "path";
function usage(code = 0) {
  console.log(`
PNP CLI

Usage:
  pnp create market "<question>" [--liquidity <lamports>] [--end <iso|days>]
  pnp trade <marketId> buy <YES|NO> <amount_usdc>
  pnp trade <marketId> sell <YES|NO> <amount_base_units>
  pnp trade <marketId> balance
  pnp trade <marketId> prices
  pnp status <marketId>
  pnp fetchMarkets
  pnp settlementCritera <marketId>

Env:
  RPC_URL, WALLET_SECRET_ARRAY | WALLET_BS58 | WALLET_FILE, [PNP_IDL_PATH]
`);
  process.exit(code);
}
function parseWalletFromEnv() {
  const secretArr = process.env.WALLET_SECRET_ARRAY;
  if (secretArr) {
    try {
      const arr = JSON.parse(secretArr);
      if (!Array.isArray(arr)) throw new Error("not an array");
      return Keypair.fromSecretKey(Uint8Array.from(arr));
    } catch (e) {
      throw new Error("WALLET_SECRET_ARRAY must be a JSON array of numbers");
    }
  }
  const secretBs58 = process.env.WALLET_BS58;
  if (secretBs58) {
    try {
      const bytes = bs58.decode(secretBs58);
      return Keypair.fromSecretKey(Uint8Array.from(bytes));
    } catch (e) {
      throw new Error("WALLET_BS58 must be a valid base58-encoded secret key");
    }
  }
  const walletFile = process.env.WALLET_FILE;
  if (walletFile) {
    try {
      const resolved = walletFile.startsWith("~") ? path.join(process.env.HOME || "", walletFile.slice(1)) : path.resolve(walletFile);
      const content = fs.readFileSync(resolved, "utf8");
      const parsed = JSON.parse(content);
      if (!Array.isArray(parsed)) {
        throw new Error("Expected JSON array in WALLET_FILE");
      }
      return Keypair.fromSecretKey(Uint8Array.from(parsed));
    } catch (e) {
      throw new Error(`Failed to read WALLET_FILE: ${e?.message || e}`);
    }
  }
  throw new Error("Wallet not provided. Set one of WALLET_SECRET_ARRAY (JSON array), WALLET_BS58 (base58), or WALLET_FILE (path to JSON array).");
}
function hexToBigInt(hex) {
  return BigInt("0x" + hex);
}
function hexToNumberSafe(hex) {
  const n = hexToBigInt(hex);
  return n > BigInt(Number.MAX_SAFE_INTEGER) ? null : Number(n);
}
function hexUnixSecondsToISOString(hex) {
  const seconds = Number(hexToBigInt(hex));
  return new Date(seconds * 1e3).toISOString();
}
var DEFAULT_PROXY_BASE_URL = "https://proxyserver-production-f61b.up.railway.app";
var MARKET_ADDRESSES_ENDPOINT = "/market-oracle/market-addresses";
async function fetchMarketAddressesFromProxy(baseUrl = process.env.PROXY_BASE_URL || DEFAULT_PROXY_BASE_URL) {
  const trimmed = baseUrl.replace(/\/+$/, "");
  const url = `${trimmed}${MARKET_ADDRESSES_ENDPOINT}`;
  const res = await fetch(url, {
    method: "GET",
    headers: { "Content-Type": "application/json" }
  });
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`Proxy request failed (${res.status} ${res.statusText}): ${text}`);
  }
  const data = await res.json().catch(() => {
    throw new Error("Failed to parse JSON from proxy response");
  });
  if (Array.isArray(data)) return data.map(String);
  if (data && Array.isArray(data.addresses)) return data.addresses.map(String);
  if (data && typeof data.success !== "undefined" && data.data && Array.isArray(data.data.addresses)) {
    return data.data.addresses.map(String);
  }
  if (data && Array.isArray(data.data)) return data.data.map(String);
  throw new Error("Unexpected proxy response shape. Expected array, {addresses: string[]}, {data: string[]}, or { success, data: { addresses: string[] } }.");
}
async function main() {
  const args = process.argv.slice(2);
  if (args.length === 0) usage(1);
  const [cmd, subcmd, ...rest] = args;
  if (cmd === "fetchMarkets") {
    const base = process.env.PROXY_BASE_URL || DEFAULT_PROXY_BASE_URL;
    const addresses = await fetchMarketAddressesFromProxy(base);
    if (!addresses.length) {
      console.log("\nNo market addresses returned by the proxy.");
      return;
    }
    console.log(`
Received ${addresses.length} market addresses:`);
    for (const addr of addresses) console.log(addr);
    return;
  }
  if (cmd === "settlementCritera") {
    const marketStr = subcmd;
    if (!marketStr) {
      usage(1);
    }
    const rpcUrlForReadOnly = process.env.RPC_URL || "https://api.mainnet-beta.solana.com";
    const sdkReadOnly = new PNPClient(rpcUrlForReadOnly);
    const criteria = await sdkReadOnly.getSettlementCriteria(marketStr);
    console.log(JSON.stringify(criteria, null, 2));
    return;
  }
  const rpcUrl = process.env.RPC_URL;
  if (!rpcUrl) throw new Error("RPC_URL must be set");
  const signer = parseWalletFromEnv();
  const sdk = new PNPClient(rpcUrl, signer.secretKey);
  if (cmd === "create" && (subcmd === "market" || !subcmd)) {
    let question = rest.join(" ").trim();
    const qi = args.findIndex((a) => a === "--question" || a === "-q");
    if (!question && qi >= 0) {
      const flagVal = args[qi + 1];
      if (typeof flagVal === "string" && flagVal.length > 0) {
        question = flagVal;
      }
    }
    if (!question || question.length === 0) {
      console.error("Missing question");
      usage(1);
    }
    const questionStr = question;
    const liIdx = args.findIndex((a) => a === "--liquidity" || a === "-l");
    const initialLiquidityNum = liIdx >= 0 && args[liIdx + 1] ? Number(args[liIdx + 1]) : 5e7;
    if (!Number.isFinite(initialLiquidityNum) || initialLiquidityNum <= 0) {
      throw new Error("Invalid --liquidity value");
    }
    const initialLiquidity = BigInt(Math.floor(initialLiquidityNum));
    let endDate = new Date(Date.now() + 7 * 24 * 3600 * 1e3);
    const endIdx = args.findIndex((a) => a === "--end");
    const daysIdx = args.findIndex((a) => a === "--days");
    if (endIdx >= 0 && typeof args[endIdx + 1] === "string") {
      const d = new Date(args[endIdx + 1]);
      if (isNaN(d.getTime())) throw new Error("Invalid --end date");
      endDate = d;
    } else if (daysIdx >= 0 && typeof args[daysIdx + 1] === "string") {
      const days = Number(args[daysIdx + 1]);
      if (!Number.isFinite(days) || days <= 0) throw new Error("Invalid --days value");
      endDate = new Date(Date.now() + days * 24 * 3600 * 1e3);
    }
    const endTime = BigInt(Math.floor(endDate.getTime() / 1e3));
    const COLLATERAL_TOKEN_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
    const collateralTokenMint = new PublicKey(COLLATERAL_TOKEN_MINT);
    const res = await sdk.anchorMarket.createMarket({ question: questionStr, initialLiquidity, endTime, collateralTokenMint });
    const md = res.marketDetails;
    if (md && typeof md === "object") {
      const decoded = {
        id: md.id,
        resolved: md.resolved,
        marketReserves: typeof md.marketReserves === "string" ? hexToNumberSafe(md.marketReserves) : md.marketReserves,
        initialLiquidity: typeof md.initialLiquidity === "string" ? hexToNumberSafe(md.initialLiquidity) : md.initialLiquidity,
        yesTokenSupplyMinted: typeof md.yesTokenSupplyMinted === "string" ? hexToNumberSafe(md.yesTokenSupplyMinted) : md.yesTokenSupplyMinted,
        noTokenSupplyMinted: typeof md.noTokenSupplyMinted === "string" ? hexToNumberSafe(md.noTokenSupplyMinted) : md.noTokenSupplyMinted,
        endTime: typeof md.endTime === "string" ? hexUnixSecondsToISOString(md.endTime) : md.endTime,
        creationTime: typeof md.creationTime === "string" ? hexUnixSecondsToISOString(md.creationTime) : md.creationTime,
        collateralToken: md.collateralToken,
        creator: md.creator,
        creatorFeeTreasury: md.creatorFeeTreasury,
        resolvable: md.resolvable,
        forceResolve: md.forceResolve,
        winningTokenId: md.winningTokenId
      };
      console.log("\nDecoded Market Details:");
      console.log("------------------------");
      Object.entries(decoded).forEach(([k, v]) => {
        console.log(`${k}: ${typeof v === "object" ? JSON.stringify(v) : v}`);
      });
      console.log("------------------------\n");
    }
    if (md && typeof md === "object") {
      const { yesTokenMint, noTokenMint, ...mdSansMints } = md;
      const sanitized = { success: true, ...res, marketDetails: mdSansMints };
      console.log(JSON.stringify(sanitized, null, 2));
    } else {
      console.log(JSON.stringify({ success: true, ...res }, null, 2));
    }
    return;
  }
  if (cmd === "status") {
    const marketStr = subcmd;
    if (!marketStr) {
      usage(1);
    }
    const marketPk = new PublicKey(marketStr);
    const info = await sdk.trading.getMarketInfo(marketPk);
    const rawEnd = info.endTime;
    let endSec = null;
    if (typeof rawEnd === "bigint") endSec = Number(rawEnd);
    else if (typeof rawEnd === "number") endSec = rawEnd;
    else if (typeof rawEnd === "string") {
      const hex = /^[0-9a-fA-F]+$/.test(rawEnd);
      try {
        endSec = Number(hex ? BigInt("0x" + rawEnd) : BigInt(rawEnd));
      } catch {
        const n = Number(rawEnd);
        endSec = Number.isFinite(n) ? n : null;
      }
    }
    const nowSec = Math.floor(Date.now() / 1e3);
    const ended = endSec !== null ? nowSec >= endSec : false;
    const endIso = endSec ? new Date(endSec * 1e3).toISOString() : "unknown";
    console.log("Market Status:");
    console.log("--------------");
    console.log(`market: ${info.address.toBase58()}`);
    console.log(`resolvable: ${info.resolvable}`);
    console.log(`resolved: ${info.resolved}`);
    console.log(`tradable: ${info.resolvable === true && info.resolved === false && !ended}`);
    if (endSec !== null) {
      console.log(`endTimeSeconds: ${endSec}`);
      console.log(`endTimeISO: ${endIso}`);
    }
    console.log(`ended: ${ended}`);
    console.log("--------------");
    return;
  }
  if (cmd === "trade") {
    if (!subcmd) {
      usage(1);
    }
    const marketStr = subcmd;
    const action = (rest[0] || "").toLowerCase();
    const side = (rest[1] || "").toUpperCase();
    const amountArg = rest[2];
    const marketPk = new PublicKey(marketStr);
    if (action === "balance") {
      const bals = await sdk.trading.getBalances(marketPk);
      console.log("Balances:");
      console.log(`  USDC: ${bals.collateral.uiAmountString}`);
      console.log(`  YES: ${bals.yes.uiAmountString}`);
      console.log(`  NO:  ${bals.no.uiAmountString}`);
      return;
    }
    if (action === "prices") {
      const p = await sdk.trading.getPrices(marketPk);
      console.log("Prices (implied shares):");
      console.log(`  YES share: ${(p.yesShare * 100).toFixed(2)}%`);
      console.log(`  NO  share: ${(p.noShare * 100).toFixed(2)}%`);
      return;
    }
    if (!marketStr || action !== "buy" && action !== "sell" || side !== "YES" && side !== "NO") {
      console.error("Usage: pnp trade <marketId> buy <YES|NO> <amount_usdc> | pnp trade <marketId> sell <YES|NO> <amount_base_units> | pnp trade <marketId> balance | pnp trade <marketId> prices");
      usage(1);
    }
    if (action === "buy") {
      if (!amountArg) {
        console.error("Missing amount_usdc");
        usage(1);
      }
      const amtUsdc = Number(amountArg);
      if (!Number.isFinite(amtUsdc) || amtUsdc <= 0) {
        console.error("Invalid amount_usdc");
        usage(1);
      }
      const buyYesToken = side === "YES";
      console.log(`\u{1F6D2} Buying ${side} with ${amtUsdc} USDC on ${marketPk.toBase58()} ...`);
      const res = await sdk.trading.buyTokensUsdc({ market: marketPk, buyYesToken, amountUsdc: amtUsdc, minimumOut: 0n });
      console.log(`\u2705 Trade submitted: ${res.signature}`);
      console.log(`\u{1F4B8} USDC Spent: ${res.usdcSpent}`);
      console.log(`\u{1F3AF} ${side} Tokens Received: ${res.tokensReceived}`);
      return;
    } else {
      if (!amountArg) {
        console.error("Missing amount_base_units");
        usage(1);
      }
      const amtBase = BigInt(amountArg);
      if (amtBase <= 0n) {
        console.error("Invalid amount_base_units");
        usage(1);
      }
      const burnYesToken = side === "YES";
      console.log(`\u{1F3EA} Selling ${side} amount=${amtBase.toString()} (base units) on ${marketPk.toBase58()} ...`);
      const res = await sdk.trading.sellTokensBase({ market: marketPk, burnYesToken, amountBaseUnits: amtBase });
      console.log(`\u2705 Trade submitted: ${res.signature}`);
      console.log(`\u{1F3EA} ${side} Tokens Sold: ${res.tokensSold}`);
      console.log(`\u{1F4B0} USDC Received: ${res.usdcReceived}`);
      return;
    }
  }
  usage(1);
}
main().catch((err) => {
  console.error(err?.message || err);
  process.exit(1);
});
//# sourceMappingURL=cli.js.map