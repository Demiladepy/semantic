import * as _solana_web3_js from '@solana/web3.js';
import { Connection, PublicKey, Commitment as Commitment$1, Transaction, VersionedTransaction, Keypair } from '@solana/web3.js';
import { z } from 'zod';
import * as anchor from '@coral-xyz/anchor';
import { Idl } from '@coral-xyz/anchor';
import { BN } from 'bn.js';

type Commitment = "processed" | "confirmed" | "finalized";
interface Logger {
    debug?: (...args: any[]) => void;
    info?: (...args: any[]) => void;
    warn?: (...args: any[]) => void;
    error?: (...args: any[]) => void;
}
interface SdkConfig {
    rpcUrl: string;
    commitment?: Commitment;
    httpHeaders?: Record<string, string>;
    priorityFeeMicroLamports?: number;
    computeUnitLimit?: number;
    computeUnitPriceMicroLamports?: number;
    addressLookupTables?: unknown[];
    logger?: Logger;
}
declare class SdkError extends Error {
    code: string;
    details?: unknown;
    constructor(code: string, message: string, details?: unknown);
}
declare class ValidationError extends SdkError {
    constructor(message: string, details?: unknown);
}
declare class TransportError extends SdkError {
    constructor(message: string, details?: unknown);
}
declare class ProgramError extends SdkError {
    programErrorCode?: number;
    logs?: string[];
    constructor(message: string, details?: unknown, programErrorCode?: number, logs?: string[]);
}
type PubkeyLike = string;
type U64Like = bigint | number | string;
type WinningTokenLike = "none" | "yes" | "no" | number | Record<string, unknown> | null;
interface MarketType {
    id: U64Like;
    resolved: boolean;
    market_reserves: U64Like;
    collateral_token: PubkeyLike;
    winning_token_id: WinningTokenLike;
    yes_token_mint: PubkeyLike;
    no_token_mint: PubkeyLike;
    yes_token_supply_minted: U64Like;
    no_token_supply_minted: U64Like;
    creator: PubkeyLike;
    creator_fee_treasury: PubkeyLike;
    question: string;
    initial_liquidity: U64Like;
    end_time: U64Like;
    bump: number;
    creation_time: U64Like;
    resolvable: boolean;
    force_resolve: boolean;
    version: number;
}
interface MarketsResponse {
    count: number;
    data: Array<{
        publicKey: string;
        account: MarketType;
    }>;
}
interface GlobalConfigType {
    admin: PubkeyLike;
    oracle_program: PubkeyLike;
    fee: U64Like;
    creator_fee: U64Like;
    bump: number;
    yes_global_metadata: string;
    no_global_metadata: string;
    collateral_token_mint: PubkeyLike;
    global_id: U64Like;
    min_liquidity: U64Like;
    buffer_period: U64Like;
    burn_fee: U64Like;
    trading_paused: boolean;
}
interface SettlementCriteria {
    category: string;
    reasoning: string;
    resolvable: boolean;
    resolution_sources: string[];
    settlement_criteria: string;
    suggested_improvements: string;
}
interface SettlementData {
    answer: string;
    reasoning: string;
    resolved?: boolean;
    winning_token_id?: string;
    resolution_time?: string;
    settlement_description?: string;
    resolution_source?: string;
}
interface MarketMeta {
    market: string;
    market_volume: number;
    image: string | null;
    initial_liquidity: number;
}
/**
 * Web3-agnostic shape for the result of a P2P market operation.
 * Note: The Anchor-based module returns actual PublicKey instances at runtime.
 * When exposing results at the SDK boundary, prefer serializing these to base58 strings to match P2PMarketResponse.
 */
interface P2PMarketResponse {
    signature: string;
    market: PubkeyLike;
    yesTokenMint: PubkeyLike;
    noTokenMint: PubkeyLike;
}

declare class Client {
    readonly connection: Connection;
    readonly programId: PublicKey;
    readonly commitment: Commitment$1;
    readonly logger: Logger;
    readonly isDevnet: boolean;
    constructor(cfg: SdkConfig);
    fail(code: string, message: string, details?: unknown): TransportError;
}

type AccountsMap = Record<string, PublicKey>;

type CreateMarketArgs = {
    question: string;
    initial_liquidity: bigint;
    end_time: bigint;
    creator?: PublicKey;
    yes_odds_bps?: number;
    oracle?: PublicKey;
};
type MintDecisionTokensArgs = {
    amount: bigint;
    buy_yes_token: boolean;
    minimum_out: bigint;
};
type BurnDecisionTokensArgs = {
    amount: bigint;
    burn_yes_token: boolean;
};
type SetMarketResolvableV2Args = {
    market_id: bigint;
    resolvable: boolean;
    force_resolve?: boolean;
};
type SetMarketResolvableV3Args = {
    resolvable: boolean;
};

interface SignerLike {
    publicKey: PublicKey;
    signTransaction(tx: Transaction | VersionedTransaction): Promise<Transaction | VersionedTransaction>;
    signAllTransactions?(txs: (Transaction | VersionedTransaction)[]): Promise<(Transaction | VersionedTransaction)[]>;
}

declare const CreateMarketSchema: z.ZodObject<{
    baseMint: z.ZodOptional<z.ZodType<PublicKey, z.ZodTypeDef, PublicKey>>;
    quoteMint: z.ZodOptional<z.ZodType<PublicKey, z.ZodTypeDef, PublicKey>>;
    question: z.ZodOptional<z.ZodString>;
    initialLiquidity: z.ZodOptional<z.ZodBigInt>;
    endTime: z.ZodOptional<z.ZodBigInt>;
    tickSize: z.ZodOptional<z.ZodBigInt>;
    lotSize: z.ZodOptional<z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    question?: string | undefined;
    initialLiquidity?: bigint | undefined;
    endTime?: bigint | undefined;
    baseMint?: PublicKey | undefined;
    quoteMint?: PublicKey | undefined;
    tickSize?: bigint | undefined;
    lotSize?: bigint | undefined;
}, {
    question?: string | undefined;
    initialLiquidity?: bigint | undefined;
    endTime?: bigint | undefined;
    baseMint?: PublicKey | undefined;
    quoteMint?: PublicKey | undefined;
    tickSize?: bigint | undefined;
    lotSize?: bigint | undefined;
}>;
declare class MarketModule {
    private readonly client;
    private readonly signer;
    constructor(client: Client, signer: SignerLike);
    createMarket(params: z.infer<typeof CreateMarketSchema>): Promise<{
        signature: string | undefined;
        market: PublicKey;
    }>;
    createMarketIdl(accounts: AccountsMap, args: CreateMarketArgs): Promise<{
        signature: string | undefined;
    }>;
    createMarketDerived(params: {
        question: string;
        initialLiquidity: bigint;
        endTime: bigint;
        collateralMint?: PublicKey;
    }): Promise<{
        signature: string | undefined;
        market: PublicKey;
    }>;
    fetchGlobalConfig(): Promise<{
        publicKey: PublicKey;
        account: any;
    }>;
    fetchMarket(market: PublicKey): Promise<{
        publicKey: PublicKey;
        account: any;
    }>;
    /**
     * ⚠️ DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
     * It will NOT work on mainnet. Use this only for development and testing.
     */
    setMarketResolvableIdl(accounts: AccountsMap, args: SetMarketResolvableV2Args): Promise<{
        signature: string;
    }>;
    /**
     * Set market resolvable status for V2 markets.
     *
     * ⚠️ DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
     * It will NOT work on mainnet. Use this only for development and testing.
     *
     * @param params - Parameters for setting market resolvable status
     * @param params.market - Market public key
     * @param params.resolvable - New resolvable status (true/false)
     * @param params.forceResolve - Optional: force resolve (allow immediate refunds)
     * @returns Transaction signature
     */
    setMarketResolvable(params: {
        market: PublicKey;
        resolvable: boolean;
        forceResolve?: boolean;
    }): Promise<{
        signature: string;
    }>;
    /**
     * ⚠️ DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
     * It will NOT work on mainnet. Use this only for development and testing.
     */
    setMarketResolvableP2pIdl(accounts: AccountsMap, args: SetMarketResolvableV3Args): Promise<{
        signature: string;
    }>;
    /**
     * Set market resolvable status for V3/P2P markets.
     *
     * ⚠️ DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
     * It will NOT work on mainnet. Use this only for development and testing.
     *
     * @param params - Parameters for setting market resolvable status
     * @param params.market - Market public key
     * @param params.resolvable - New resolvable status (true/false)
     * @returns Transaction signature
     */
    setMarketResolvableP2p(params: {
        market: PublicKey;
        resolvable: boolean;
    }): Promise<{
        signature: string;
    }>;
}

declare const TradeSchema: z.ZodObject<{
    market: z.ZodType<PublicKey, z.ZodTypeDef, PublicKey>;
    side: z.ZodUnion<[z.ZodLiteral<"buy">, z.ZodLiteral<"sell">]>;
    price: z.ZodBigInt;
    size: z.ZodBigInt;
}, "strip", z.ZodTypeAny, {
    market: PublicKey;
    side: "buy" | "sell";
    price: bigint;
    size: bigint;
}, {
    market: PublicKey;
    side: "buy" | "sell";
    price: bigint;
    size: bigint;
}>;
declare class TradingModule {
    private readonly client;
    private readonly signer;
    constructor(client: Client, signer: SignerLike);
    private static readonly MARKET_CREATED_V3_DISCRIMINATOR;
    private decodeMarketAny;
    trade(params: z.infer<typeof TradeSchema>): Promise<{
        signature: string | undefined;
    }>;
    mintDecisionTokens(accounts: AccountsMap, args: MintDecisionTokensArgs): Promise<{
        signature: string | undefined;
    }>;
    burnDecisionTokens(accounts: AccountsMap, args: BurnDecisionTokensArgs): Promise<{
        signature: string | undefined;
    }>;
    mintDecisionTokensDerived(params: {
        market: PublicKey;
        amount: bigint;
        buyYesToken: boolean;
        minimumOut: bigint;
    }): Promise<{
        signature: string | undefined;
    }>;
    burnDecisionTokensDerived(params: {
        market: PublicKey;
        amount: bigint;
        burnYesToken: boolean;
    }): Promise<{
        signature: string | undefined;
    }>;
    getMarketInfo(market: PublicKey): Promise<{
        address: PublicKey;
        question: any;
        id: any;
        creator: PublicKey;
        initialLiquidity: any;
        marketReserves: any;
        endTime: any;
        resolvable: any;
        resolved: any;
        winningTokenId: any;
        yesTokenMint: PublicKey;
        noTokenMint: PublicKey;
        collateralToken: PublicKey;
        yesTokenSupplyMinted: any;
        noTokenSupplyMinted: any;
    }>;
    getBalances(market: PublicKey): Promise<{
        collateral: {
            account: PublicKey;
            amount: any;
            uiAmount: any;
            uiAmountString: any;
        };
        yes: {
            account: PublicKey;
            amount: any;
            uiAmount: any;
            uiAmountString: any;
        };
        no: {
            account: PublicKey;
            amount: any;
            uiAmount: any;
            uiAmountString: any;
        };
    }>;
    getPrices(market: PublicKey): Promise<{
        yesMinted: number;
        noMinted: number;
        totalMinted: number;
        yesShare: number;
        noShare: number;
    }>;
    buyTokensUsdc(params: {
        market: PublicKey;
        buyYesToken: boolean;
        amountUsdc: number;
        minimumOut?: bigint;
    }): Promise<{
        signature: string;
        usdcSpent: number;
        tokensReceived: number;
        before: {
            collateral: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
            yes: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
            no: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
        };
        after: {
            collateral: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
            yes: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
            no: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
        };
    }>;
    sellTokensBase(params: {
        market: PublicKey;
        burnYesToken: boolean;
        amountBaseUnits: bigint;
    }): Promise<{
        signature: string;
        tokensSold: number;
        usdcReceived: number;
        before: {
            collateral: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
            yes: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
            no: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
        };
        after: {
            collateral: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
            yes: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
            no: {
                account: PublicKey;
                amount: any;
                uiAmount: any;
                uiAmountString: any;
            };
        };
    }>;
    redeemPosition(market: PublicKey): Promise<void>;
}

declare const RedeemSchema: z.ZodObject<{
    market: z.ZodType<PublicKey, z.ZodTypeDef, PublicKey>;
    position: z.ZodType<PublicKey, z.ZodTypeDef, PublicKey>;
    amount: z.ZodBigInt;
    to: z.ZodOptional<z.ZodType<PublicKey, z.ZodTypeDef, PublicKey>>;
}, "strip", z.ZodTypeAny, {
    market: PublicKey;
    amount: bigint;
    position: PublicKey;
    to?: PublicKey | undefined;
}, {
    market: PublicKey;
    amount: bigint;
    position: PublicKey;
    to?: PublicKey | undefined;
}>;
declare class RedemptionModule {
    private readonly client;
    private readonly signer;
    constructor(client: Client, signer: SignerLike);
    redeemPosition(params: z.infer<typeof RedeemSchema>): Promise<{
        signature: string | undefined;
    }>;
    claimCreatorFee(accounts: AccountsMap): Promise<{
        signature: string | undefined;
    }>;
    creatorRefund(accounts: AccountsMap): Promise<{
        signature: string | undefined;
    }>;
    creatorRefundV2(accounts: AccountsMap): Promise<{
        signature: string | undefined;
    }>;
    creatorRefundV3(accounts: AccountsMap): Promise<{
        signature: string | undefined;
    }>;
    /**
     * Redeem a winning position from a resolved market
     * @param accounts - Account mapping for the redemption instruction
     * @returns Transaction signature
     */
    redeemPositionV2(accounts: AccountsMap): Promise<{
        signature: string | undefined;
    }>;
    /**
     * Redeem a winning position from a resolved V3 market
     * @param accounts - Account mapping for the V3 redemption instruction
     * @returns Transaction signature
     */
    redeemV3Position(accounts: AccountsMap): Promise<{
        signature: string | undefined;
    }>;
}

/**
 * Provides a wrapper for Anchor program interactions
 * Following the same pattern as the JavaScript example
 */
declare class AnchorClient {
    readonly connection: Connection;
    readonly signer: Keypair;
    readonly idlOverride?: Idl | undefined;
    readonly programIdOverride?: PublicKey | undefined;
    readonly provider: anchor.AnchorProvider;
    readonly wallet: anchor.Wallet;
    readonly program: anchor.Program;
    constructor(connection: Connection, signer: Keypair, idlOverride?: Idl | undefined, programIdOverride?: PublicKey | undefined);
    /**
     * Convert a JavaScript BigInt or number to Anchor BN
     */
    static toBN(value: bigint | number): typeof BN.prototype;
    /**
     * Returns the IDL for the PNP program
     */
    static getIdl(): Promise<Idl>;
    static fromIdl(connection: Connection, signer: Keypair, idl: Idl): AnchorClient;
    /**
     * Get the wallet's public key
     */
    get walletPublicKey(): PublicKey;
}

/**
 * Market module that uses direct Anchor program calls
 */
declare class AnchorMarketModule {
    private anchorClient;
    constructor(anchorClient: AnchorClient);
    /**
     * Create a new prediction market using direct Anchor program calls
     * Following the same structure as the working JavaScript example
     */
    createMarket(params: {
        question: string;
        initialLiquidity: bigint;
        endTime: bigint;
        collateralTokenMint: PublicKey;
        creator?: PublicKey;
        yesOddsBps?: number;
        oracle?: PublicKey;
    }): Promise<{
        signature: any;
        market: PublicKey;
        marketDetails: any;
    } | {
        signature: any;
        market: PublicKey;
        marketDetails?: undefined;
    }>;
}

type TokenSide = "yes" | "no";
/**
 * Market module that uses direct Anchor program calls for V3 markets
 */
declare class AnchorMarketV3Module {
    private anchorClient;
    constructor(anchorClient: AnchorClient);
    /**
     * Create a new V3 prediction market using direct Anchor program calls
     */
    createMarketV3(params: {
        question: string;
        initialAmount: bigint;
        side: TokenSide;
        creatorSideCap: bigint;
        endTime: bigint;
        maxPotRatio?: number;
        collateralTokenMint: PublicKey;
        creator?: PublicKey;
        oddsBps?: number;
        oracle?: PublicKey;
    }): Promise<{
        signature: any;
        market: PublicKey;
        yesTokenMint: PublicKey;
        noTokenMint: PublicKey;
    }>;
}

declare class PNPClient {
    readonly client: Client;
    readonly signer?: SignerLike;
    readonly market?: MarketModule;
    readonly trading?: TradingModule;
    readonly redemption?: RedemptionModule;
    readonly anchorMarket?: AnchorMarketModule;
    readonly anchorMarketV3?: AnchorMarketV3Module;
    readonly anchorClient?: AnchorClient;
    private static readonly MARKET_V3_DISCRIMINATOR;
    get connection(): _solana_web3_js.Connection;
    /**
     * Decode market account data from buffer
     * @param data Buffer containing account data
     * @returns Decoded market account data
     */
    private decodeMarketAny;
    constructor(rpcUrl: string, privateKey?: Uint8Array | string | {
        secretKey: Uint8Array;
    });
    /**
     * Create a P2P market (high-level wrapper) and return a web3-agnostic result.
     * Serializes PublicKeys to base58 strings to match P2PMarketResponse.
     */
    createP2PMarketGeneral(params: {
        question: string;
        initialAmount: bigint;
        side: "yes" | "no";
        creatorSideCap: bigint;
        endTime: bigint;
        maxPotRatio?: number;
        collateralTokenMint: PublicKey;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse>;
    /**
     * Create a P2P market using simple, UI-friendly parameters.
     * - Accepts amount in USDC (number) and converts to raw units internally (assumes 6 decimals).
     * - Defaults to mainnet USDC as collateral mint if not provided.
     * - Defaults creatorSideCap to 5x the initial amount if not provided.
     * - Defaults end time to `daysUntilEnd` days from now (30 days by default).
     */
    createP2PMarketSimple(params: {
        question: string;
        side: "yes" | "no";
        amountUsdc: number;
        daysUntilEnd?: number;
        creatorSideCapMultiplier?: number;
        collateralTokenMint?: PublicKey;
        maxPotRatio?: number;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse>;
    /**
     * Create a P2P market with YouTube URL detection (high-level wrapper).
     * Automatically detects and extracts YouTube URLs from the question.
     * Serializes PublicKeys to base58 strings to match P2PMarketResponse.
     */
    createP2PMarketYoutube(params: {
        question: string;
        youtubeUrl: string;
        initialAmount: bigint;
        side: "yes" | "no";
        creatorSideCap: bigint;
        endTime: bigint;
        maxPotRatio?: number;
        collateralTokenMint: PublicKey;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse & {
        detectedYoutubeUrl?: string;
    }>;
    /**
     * Create a P2P market with DeFiLlama protocol/metric detection (high-level wrapper).
     * Automatically formats the question with DeFiLlama reference.
     * Serializes PublicKeys to base58 strings to match P2PMarketResponse.
     */
    createP2PMarketDefiLlama(params: {
        question: string;
        protocolName: string;
        metric: string;
        initialAmount: bigint;
        side: "yes" | "no";
        creatorSideCap: bigint;
        endTime: bigint;
        maxPotRatio?: number;
        collateralTokenMint: PublicKey;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse & {
        detectedProtocol?: string;
        detectedMetric?: string;
    }>;
    /**
     * Simple helper to create a P2P market with a YouTube URL using UI-friendly parameters.
     * - Accepts amount in USDC (number) and converts to raw units internally (assumes 6 decimals).
     * - Defaults to mainnet USDC as collateral mint if not provided.
     * - Defaults creatorSideCap to 5x the initial amount if not provided.
     * - Defaults end time to `daysUntilEnd` days from now (30 days by default).
     */
    createP2PMarketYoutubeSimple(params: {
        question: string;
        youtubeUrl: string;
        side: "yes" | "no";
        amountUsdc: number;
        daysUntilEnd?: number;
        creatorSideCapMultiplier?: number;
        collateralTokenMint?: PublicKey;
        maxPotRatio?: number;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse & {
        detectedYoutubeUrl?: string;
    }>;
    /**
     * Create a V2 (AMM) market with Twitter URL detection (high-level wrapper).
     * Automatically detects and extracts Twitter URLs from the question.
     * Serializes PublicKeys to base58 strings.
     */
    createMarketTwitter(params: {
        question: string;
        tweetUrl: string;
        initialLiquidity: bigint;
        endTime: bigint;
        collateralTokenMint: PublicKey;
    }): Promise<{
        signature: string;
        market: string;
        detectedTwitterUrl?: string;
        isTweetIdFormat?: boolean;
    }>;
    /**
     * Create a V2 (AMM) market with YouTube URL detection (high-level wrapper).
     * Automatically detects and extracts YouTube URLs from the question.
     * Serializes PublicKeys to base58 strings.
     */
    createMarketYoutube(params: {
        question: string;
        youtubeUrl: string;
        initialLiquidity: bigint;
        endTime: bigint;
        collateralTokenMint: PublicKey;
    }): Promise<{
        signature: string;
        market: string;
        detectedYoutubeUrl?: string;
    }>;
    /**
     * Create a V2 (AMM) market with DeFiLlama protocol/metric detection (high-level wrapper).
     * Automatically formats the question with DeFiLlama reference.
     * Serializes PublicKeys to base58 strings.
     */
    createMarketDefiLlama(params: {
        question: string;
        protocolName: string;
        metric: string;
        initialLiquidity: bigint;
        endTime: bigint;
        collateralTokenMint: PublicKey;
    }): Promise<{
        signature: string;
        market: string;
        detectedProtocol?: string;
        detectedMetric?: string;
    }>;
    /**
     * Create a P2P market with Twitter URL detection (high-level wrapper).
     * Automatically detects and extracts Twitter URLs from the question.
     * Serializes PublicKeys to base58 strings to match P2PMarketResponse.
     */
    createP2PMarketTwitter(params: {
        question: string;
        tweetUrl: string;
        initialAmount: bigint;
        side: "yes" | "no";
        creatorSideCap: bigint;
        endTime: bigint;
        maxPotRatio?: number;
        collateralTokenMint: PublicKey;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse & {
        detectedTwitterUrl?: string;
        isTweetIdFormat?: boolean;
    }>;
    /**
     * Simple helper to create a P2P market with a Twitter / X URL using UI-friendly parameters.
     * - Accepts amount in USDC (number) and converts to raw units internally (assumes 6 decimals).
     * - Defaults to mainnet USDC as collateral mint if not provided.
     * - Defaults creatorSideCap to 5x the initial amount if not provided.
     * - Defaults end time to `daysUntilEnd` days from now (30 days by default).
     */
    createP2PMarketTwitterSimple(params: {
        question: string;
        tweetUrl: string;
        side: "yes" | "no";
        amountUsdc: number;
        daysUntilEnd?: number;
        creatorSideCapMultiplier?: number;
        collateralTokenMint?: PublicKey;
        maxPotRatio?: number;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse & {
        detectedTwitterUrl?: string;
        isTweetIdFormat?: boolean;
    }>;
    /**
     * Simple helper to create a P2P market with DeFiLlama protocol/metric using UI-friendly parameters.
     * - Accepts amount in USDC (number) and converts to raw units internally (assumes 6 decimals).
     * - Defaults to mainnet USDC as collateral mint if not provided.
     * - Defaults creatorSideCap to 5x the initial amount if not provided.
     * - Defaults end time to `daysUntilEnd` days from now (30 days by default).
     */
    createP2PMarketDefiLlamaSimple(params: {
        question: string;
        protocolName: string;
        metric: string;
        side: "yes" | "no";
        amountUsdc: number;
        daysUntilEnd?: number;
        creatorSideCapMultiplier?: number;
        collateralTokenMint?: PublicKey;
        maxPotRatio?: number;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse & {
        detectedProtocol?: string;
        detectedMetric?: string;
    }>;
    /**
     * Create a V2 (AMM) market with custom initial odds and/or a custom oracle.
     *
     * @param params - Market creation parameters
     * @param params.yesOddsBps - Initial YES odds in basis points (100-9900).
     *   Example: 7000 = 70% YES / 30% NO
     * @param params.oracle - Optional custom oracle for settlement (default: global oracle)
     * @returns Object with transaction signature and market PDA
     */
    createMarketV2WithCustomOdds(params: {
        question: string;
        initialLiquidity: bigint;
        endTime: bigint;
        collateralTokenMint: PublicKey;
        yesOddsBps: number;
        oracle?: PublicKey;
        creator?: PublicKey;
    }): Promise<{
        signature: any;
        market: string;
    }>;
    /**
     * Create a P2P (V3) market with custom initial odds (high-level wrapper).
     * Custom odds allow splitting the initial liquidity between YES and NO sides
     * instead of the default 100% to creator side.
     *
     * @param params - Market creation parameters
     * @param params.oddsBps - Initial odds in basis points (100-9900).
     *   Example: 7000 = 70% YES / 30% NO for a YES-side creator
     * @param params.oracle - Optional custom oracle for settlement (default: global oracle)
     * @returns P2PMarketResponse with market address and token mints
     */
    createMarketP2PWithCustomOdds(params: {
        question: string;
        initialAmount: bigint;
        side: "yes" | "no";
        creatorSideCap: bigint;
        endTime: bigint;
        oddsBps: number;
        oracle?: PublicKey;
        maxPotRatio?: number;
        collateralTokenMint: PublicKey;
        creator?: PublicKey;
    }): Promise<P2PMarketResponse>;
    /**
     * Detects if a question contains a Twitter URL or tweet ID format after the question mark
     * @param questionText The question text to analyze
     * @returns Object containing the cleaned question, Twitter URL if present, and isTweetIdFormat flag indicating if X {tweet_id} format was used
     * @example
     * // With URL format
     * detectTwitterUrl("Will X happen? https://twitter.com/user/status/1234567890");
     * // With X {tweet id} format - with space
     * detectTwitterUrl("Will X happen? X 1234567890");
     * // With X {tweet id} format - with curly braces
     * detectTwitterUrl("Will X happen? X {1234567890}");
     */
    static detectTwitterUrl(questionText: string): {
        question: string;
        twitterUrl?: string;
        isTweetIdFormat?: boolean;
    };
    /**
     * Detects if a question contains a YouTube URL after the question mark
     * @param questionText The question text to analyze
     * @returns Object containing the cleaned question and YouTube URL if present
     */
    static detectYoutubeUrl(questionText: string): {
        question: string;
        youtubeUrl?: string;
    };
    /**
     * Detects if a question contains a DeFiLlama format after the question mark
     * @param questionText The question text to analyze
     * @returns Object containing the cleaned question and DeFiLlama protocol/metric info if present
     * @example
     * detectDefiLlamaUrl("Will Uniswap TVL exceed $5B? df uniswap-v3 tvl");
     */
    static detectDefiLlamaUrl(questionText: string): {
        question: string;
        protocol?: string;
        metric?: string;
    };
    /**
     * Parse a private key from a string that could be a JSON array or base58 encoded
     * @param keyString Private key as JSON array or base58 string
     * @returns Uint8Array containing the private key bytes
     */
    static parseSecretKey(keyString: string): Uint8Array;
    /**
     * Convert UI amount to raw amount based on decimals (defaults to 6 for USDC)
     * @param amount UI amount with decimal places
     * @param decimals Token decimals (default: 6 for USDC)
     * @returns Raw token amount as bigint
     */
    uiToRaw(amount: number, decimals?: number): bigint;
    /**
     * Buy tokens on a V3 market using USDC
     * @param params Buy parameters including market, side, and amount
     * @returns Transaction signature
     */
    buyV3TokensUsdc(params: {
        market: PublicKey;
        buyYesToken: boolean;
        amountUsdc: number;
    }): Promise<{
        signature: string;
    }>;
    /**
     * Redeems a winning position in a resolved market
     * @param market - The public key of the market where the position was created
     * @param options - Optional parameters for customizing the redemption
     * @returns Transaction signature
     */
    redeemPosition(market: PublicKey, options?: {
        admin?: PublicKey;
        marketCreator?: PublicKey;
        creatorFeeTreasury?: PublicKey;
    }): Promise<{
        signature: string | undefined;
    }>;
    /**
     * Redeems a winning position in a resolved V3 market
     * @param market - The public key of the V3 market where the position was created
     * @returns Transaction signature
     */
    redeemV3Position(market: PublicKey): Promise<{
        signature: any;
    }>;
    /**
     * Redeem a winning position from a resolved P2P (V3) market.
     * Thin wrapper around redeemV3Position that accepts either a string or PublicKey.
     */
    redeemP2PPosition(market: PublicKey | string): Promise<{
        signature: string;
    }>;
    fetchGlobalConfig(): Promise<{
        publicKey: PublicKey;
        account: GlobalConfigType;
    }>;
    /**
     * Set market resolvable status (V2 markets)
     *
     * ⚠️ DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
     * It will NOT work on mainnet. Use this only for development and testing.
     *
     * @param market - Market public key or address string
     * @param resolvable - New resolvable status
     * @param forceResolve - Optional: force resolve (allow immediate refunds)
     * @returns Transaction signature
     */
    /**
     * Set market resolvable status for V2 markets.
     * Automatically handles market extension accounts for custom oracles.
     *
     * @param market - Market public key or address string
     * @param resolvable - New resolvable status (true/false)
     * @param forceResolve - Optional: force resolve (allow immediate refunds)
     * @returns Transaction signature
     */
    setMarketResolvable(market: PublicKey | string, resolvable: boolean, forceResolve?: boolean): Promise<{
        signature: string;
    }>;
    /**
     * High-level method to create a V2 market with a custom oracle (settler).
     *
     * @param params Market parameters including settler address and optional odds
     * @returns Created market details
     */
    createMarketWithCustomOracle(params: {
        question: string;
        initialLiquidity: bigint;
        endTime: bigint;
        collateralMint: PublicKey;
        settlerAddress: PublicKey;
        yesOddsBps?: number;
    }): Promise<{
        market: PublicKey;
        signature: string;
    }>;
    /**
     * Set market resolvable status (V3/P2P markets)
     *
     * ⚠️ DEVNET/TESTING ONLY - This function is for devnet and testing purposes only.
     * It will NOT work on mainnet. Use this only for development and testing.
     *
     * @param market - Market public key or address string
     * @param resolvable - New resolvable status
     * @returns Transaction signature
     */
    setMarketResolvableP2p(market: PublicKey | string, resolvable: boolean): Promise<{
        signature: string;
    }>;
    fetchMarket(market: PublicKey): Promise<{
        publicKey: PublicKey;
        account: MarketType;
    }>;
    fetchMarkets(): Promise<MarketsResponse>;
    /**
     * Fetch settlement criteria for a market from the proxy server
     * @param market - Market public key (as string or PublicKey)
     * @param baseUrl - Optional base URL for the proxy server
     * @returns Settlement criteria data
     */
    fetchSettlementCriteria(market: string | PublicKey, baseUrl?: string): Promise<SettlementCriteria>;
    /**
     * Get settlement criteria for a market from the proxy server (alias for fetchSettlementCriteria)
     * @param market - Market public key (as string or PublicKey)
     * @param baseUrl - Optional base URL for the proxy server
     * @returns Settlement criteria data
     */
    getSettlementCriteria(market: string | PublicKey, baseUrl?: string, options?: {
        retryDelayMs?: number;
        maxRetryTimeMs?: number;
    }): Promise<SettlementCriteria>;
    /**
     * Convenience helper: wait for settlement criteria and provide a small summary.
     * - Uses getSettlementCriteria() (with retry) under the hood
     * - Derives a friendly YES/NO answer when possible
     * - Surfaces resolvable if provided by the proxy
     */
    waitForSettlementCriteria(market: string | PublicKey, baseUrl?: string, options?: {
        retryDelayMs?: number;
        maxRetryTimeMs?: number;
    }): Promise<{
        resolvable?: boolean;
        answer?: string;
        criteria: SettlementCriteria;
    }>;
    /**
     * Fetch settlement data for a market from the proxy server
     * @param market - Market public key (as string or PublicKey)
     * @param baseUrl - Optional base URL for the proxy server
     * @returns Settlement data
     */
    fetchSettlementData(market: string | PublicKey, baseUrl?: string): Promise<SettlementData>;
    /**
     * Get settlement data for a market from the proxy server (alias for fetchSettlementData)
     * @param market - Market public key (as string or PublicKey)
     * @param baseUrl - Optional base URL for the proxy server
     * @returns Settlement data
     */
    getSettlementData(market: string | PublicKey, baseUrl?: string): Promise<SettlementData>;
    /**
     * Fetch market addresses from the proxy server
     * @param baseUrl - Optional base URL for the proxy server
     * @returns Array of market addresses
     */
    fetchMarketAddresses(baseUrl?: string): Promise<string[]>;
    /**
     * Get comprehensive information for a P2P market (V3), including reserves, token mints, and settlement criteria
     * @param marketAddress Market address as PublicKey or string
     * @param options Optional parameters like base URL
     * @returns Combined market info with both on-chain data and settlement criteria
     */
    getP2PMarketInfo(marketAddress: PublicKey | string, options?: {
        baseUrl?: string;
    }): Promise<{
        question: string;
        yesMint: string;
        noMint: string;
        yesReserve: string;
        noReserve: string;
        collateralMint: string;
        settlementCriteria: SettlementCriteria | null;
        endTime: Date;
    }>;
    /**
     * Get comprehensive market information for a V2 market, combining on-chain data and settlement criteria
     * @param marketAddress Market address as PublicKey or string
     * @param options Optional parameters like base URL
     * @returns Combined market info with both on-chain data and settlement criteria
     */
    getV2MarketInfo(marketAddress: PublicKey | string, options?: {
        baseUrl?: string;
    }): Promise<{
        yesMint: string;
        noMint: string;
        question: string;
        creator: string;
        settlementCriteria: SettlementCriteria | null;
        yesMultiplier: number;
        noMultiplier: number;
        endTime: Date;
    }>;
    /**
     * Fetch V3 market addresses from the proxy server
     * @param baseUrl - Optional base URL for the proxy server
     * @returns Array of market addresses
     */
    fetchV3MarketAddresses(baseUrl?: string): Promise<string[]>;
    /**
     * Get market metadata (volume, image, initial liquidity) for multiple markets in a single API call
     * @param markets - Array of market public keys (as strings or PublicKeys)
     * @param baseUrl - Optional base URL for the proxy server
     * @returns Array of market metadata including volume, image, and initial liquidity
     */
    getMarketMetaBatch(markets: (string | PublicKey)[], baseUrl?: string): Promise<MarketMeta[]>;
    /**
     * Get market metadata (volume, image, initial liquidity) for a single market
     * @param market - Market public key (as string or PublicKey)
     * @param baseUrl - Optional base URL for the proxy server
     * @returns Market metadata including volume, image, and initial liquidity
     */
    getMarketMeta(market: string | PublicKey, baseUrl?: string): Promise<MarketMeta>;
    /**
     * Claim creator refund for a market.
     * Behavior parity with scripts/claimCreatorRefund.ts:
     * - Eligible if market is not resolvable (proxy or on-chain flag) AND signer is the creator
     * - Mixed token programs => use creator_refund_v2 with accountsPartial (yes/no token mints null)
     * - Uniform token programs => try creator_refund_v2 then fallback to v1
     */
    claimMarketRefund(market: PublicKey): Promise<{
        signature: string;
    }>;
    /**
     * Claim creator refund for a P2P (V3) market by market address.
     * - Uses getP2PMarketInfo to discover collateral mint
     * - Decodes MarketV3 to discover creator
     * - Enforces that the signer is the creator
     * - Automatically wires all required PDAs and token accounts
     */
    claimP2PMarketRefund(marketAddress: PublicKey | string): Promise<{
        signature: string;
    }>;
    /**
     * Settle a V2 market by determining the winning outcome.
     * Only callable by the oracle/admin after market is resolvable.
     *
     * @param params Market address and outcome (true for YES winner, false for NO winner)
     * @returns Transaction signature
     */
    settleMarket(params: {
        market: PublicKey;
        yesWinner: boolean;
    }): Promise<{
        signature: string;
    }>;
}

declare function deriveMarketPda(baseMint: PublicKey, quoteMint: PublicKey, programId: PublicKey): [PublicKey, number];
declare function derivePositionPda(market: PublicKey, owner: PublicKey, programId: PublicKey): [PublicKey, number];
declare function deriveGlobalConfigPda(programId: PublicKey): [PublicKey, number];
declare function deriveCreatorFeeTreasuryPda(creator: PublicKey, programId: PublicKey, collateralMint: PublicKey): [PublicKey, number];
declare function deriveCreatorFeeTreasuryPdaLegacy(creator: PublicKey, programId: PublicKey): [PublicKey, number];
declare function deriveAta(owner: PublicKey, mint: PublicKey, allowOwnerOffCurve?: boolean, tokenProgramId?: PublicKey, ataProgramId?: PublicKey): PublicKey;
declare function deriveMarketPdaFromMints(yesMint: PublicKey, noMint: PublicKey, programId: PublicKey): [PublicKey, number];
declare function deriveYesTokenMint(globalId: bigint, programId: PublicKey): [PublicKey, number];
declare function deriveNoTokenMint(globalId: bigint, programId: PublicKey): [PublicKey, number];
declare function deriveTokenMetadataPda(mint: PublicKey, metadataProgramId: PublicKey): [PublicKey, number];

declare const pdas_deriveAta: typeof deriveAta;
declare const pdas_deriveCreatorFeeTreasuryPda: typeof deriveCreatorFeeTreasuryPda;
declare const pdas_deriveCreatorFeeTreasuryPdaLegacy: typeof deriveCreatorFeeTreasuryPdaLegacy;
declare const pdas_deriveGlobalConfigPda: typeof deriveGlobalConfigPda;
declare const pdas_deriveMarketPda: typeof deriveMarketPda;
declare const pdas_deriveMarketPdaFromMints: typeof deriveMarketPdaFromMints;
declare const pdas_deriveNoTokenMint: typeof deriveNoTokenMint;
declare const pdas_derivePositionPda: typeof derivePositionPda;
declare const pdas_deriveTokenMetadataPda: typeof deriveTokenMetadataPda;
declare const pdas_deriveYesTokenMint: typeof deriveYesTokenMint;
declare namespace pdas {
  export { pdas_deriveAta as deriveAta, pdas_deriveCreatorFeeTreasuryPda as deriveCreatorFeeTreasuryPda, pdas_deriveCreatorFeeTreasuryPdaLegacy as deriveCreatorFeeTreasuryPdaLegacy, pdas_deriveGlobalConfigPda as deriveGlobalConfigPda, pdas_deriveMarketPda as deriveMarketPda, pdas_deriveMarketPdaFromMints as deriveMarketPdaFromMints, pdas_deriveNoTokenMint as deriveNoTokenMint, pdas_derivePositionPda as derivePositionPda, pdas_deriveTokenMetadataPda as deriveTokenMetadataPda, pdas_deriveYesTokenMint as deriveYesTokenMint };
}

export { Client, type Commitment, type GlobalConfigType, type Logger, type MarketMeta, MarketModule, type MarketType, type MarketsResponse, type P2PMarketResponse, PNPClient, ProgramError, type PubkeyLike, RedemptionModule, type SdkConfig, SdkError, type SettlementCriteria, type SettlementData, TradingModule, TransportError, type U64Like, ValidationError, type WinningTokenLike, pdas };
